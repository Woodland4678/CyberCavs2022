// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "Subsystems/Shooter.h"
#include <frc/SmartDashboard/SmartDashboard.h>
#include <frc/Timer.h>
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS
rev::CANSparkMax leaderMotor{11, rev::CANSparkMax::MotorType::kBrushless};


rev::CANSparkMax followMotor{10, rev::CANSparkMax::MotorType::kBrushless};
rev::SparkMaxPIDController shooterPidController = leaderMotor.GetPIDController();
rev::SparkMaxRelativeEncoder shooterEncoder = leaderMotor.GetEncoder();
double spinUpP = 0.00017;
double spinUpI = 0.000001;
double spinUpD = 0.003;
double spinUpF = 0.000002;

double maintainP = 0.00001;
double maintainI = 0.000000025;
double maintainD = 0.005;
double maintainF = 0.000002;
Shooter::Shooter() : frc::Subsystem("Shooter") {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
hoodSolenoid.reset(new frc::Solenoid(0, frc::PneumaticsModuleType::CTREPCM, 0));
//AddChild("hoodSolenoid", hoodSolenoid);
shooterPositionServo.reset(new frc::Servo(1));
AddChild("ShooterPositionServo", shooterPositionServo);



    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    followMotor.Follow(leaderMotor);
    
    shooterPidController.SetP(0.00017, 0); //0.00017
    shooterPidController.SetI(0.000001, 0);
    shooterPidController.SetD(0.003, 0);
    shooterPidController.SetFF(0.000002, 0);

    shooterPidController.SetP(0.0002, 1);
    shooterPidController.SetI(0.000001, 1);
    shooterPidController.SetD(0.0, 1);
    shooterPidController.SetFF(0.00002, 1);

    shooterPidController.SetOutputRange(-1, 1);
}

void Shooter::InitDefaultCommand() {
    // Set the default command for a subsystem here.
    // SetDefaultCommand(new MySpecialCommand());
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
}

void Shooter::Periodic() {
    // Put code here to be run every loop
    frc::SmartDashboard::PutNumber("Shooter Actual RPM", shooterEncoder.GetVelocity());
    frc::SmartDashboard::PutNumber("Shooter hood position", currentHoodPosition);
    frc::SmartDashboard::PutNumber("shooter I accum", shooterPidController.GetIAccum());
    
}

int shooterSpeeedUpCount = 0;
/*
bool Shooter::SetShooterVelocity(double velocity, double shooterError, int slot) {
    shooterPidController.SetReference(velocity, rev::ControlType::kVelocity, slot);
    if (abs(shooterEncoder.GetVelocity()-velocity)<=shooterError){
        shooterSpeeedUpCount++;
        if (shooterSpeeedUpCount>=2){
             return true;
        }
    }
    else {
        shooterSpeeedUpCount = 0;
    }

    return false;
    //leaderMotor.Set(-1);
}
*/
double Shooter::SetShooterVelocity(double velocity, double shooterError, int slot) {
    shooterPidController.SetReference(velocity, rev::ControlType::kVelocity, slot);
    shooterError = abs(shooterEncoder.GetVelocity()-velocity);
    return shooterError;
}
void Shooter::SetPID(double p, double i, double d, double f, bool ignoreIAccum) {
    float iac = shooterPidController.GetIAccum();
    
    shooterPidController.SetP(p,0);
    shooterPidController.SetI(i,0);
    shooterPidController.SetD(d,0);
    shooterPidController.SetFF(f,0);
    if (!ignoreIAccum) {
        shooterPidController.SetIAccum(iac);
    }
}
void Shooter::SetPIDToSpinup(bool ignoreIAccum) {
    float iac = shooterPidController.GetIAccum();
    
    shooterPidController.SetP(spinUpP,0);
    shooterPidController.SetI(spinUpI,0);
    shooterPidController.SetD(spinUpD,0);
    shooterPidController.SetFF(spinUpF,0);
    if (!ignoreIAccum) {
        shooterPidController.SetIAccum(iac);
    }
}
void Shooter::SetPIDToMaintain(bool ignoreIAccum) {
    float iac = shooterPidController.GetIAccum();
    
    shooterPidController.SetP(maintainP,0);
    shooterPidController.SetI(maintainI,0);
    shooterPidController.SetD(maintainD,0);
    shooterPidController.SetFF(maintainF,0);
    if (!ignoreIAccum) {
        shooterPidController.SetIAccum(iac);
    }
}
void Shooter::SetHoodHighGoal() {
    hoodSolenoid->Set(true);
}
void Shooter::SetHoodLowGoal() {
    hoodSolenoid->Set(false);
}
void Shooter::StopShooterMotor() {
    leaderMotor.StopMotor();
}

void Shooter::SetServoPosition(float position) {
    shooterPositionServo->Set(position);
}
int hoodMoveToMediumState = 0;
int hoodMoveToCloseState = 0;
int hoodMoveToFarState = 0;
auto hoodMoveOriginalTime = 0_s;

double ServoCloseAndFarShotPosition = 0.8;
double ServoMediumShotPosition = 0.00;
void Shooter::SetHoodFarShot() {
	hoodSolenoid->Set(true);
    SetServoPosition(ServoMediumShotPosition);
	if (currentHoodPosition == HOODCLOSESHOTPOSITION) {
		switch (hoodMoveToFarState) {
			case 0:
				SetServoPosition(ServoMediumShotPosition);
				hoodMoveOriginalTime = frc::Timer::GetFPGATimestamp();
				hoodMoveToFarState++;
			break;
			case 1:
				if (frc::Timer::GetFPGATimestamp() - hoodMoveOriginalTime > 0.3_s) {
                    hoodMoveToFarState++;
                }
			break;
			case 2:
				//shooterPositionServo->SetDisabled();
				hoodMoveToCloseState = 2;
				hoodMoveToMediumState = 4;
                currentHoodPosition = HOODFARSHOTPOSITION;
                hoodMoveToFarState = 0;
			break;
			
		}
	} else {
        currentHoodPosition = HOODFARSHOTPOSITION;
        hoodMoveToCloseState = 2;
		hoodMoveToMediumState = 4;
    }
    
    
}
void Shooter::SetHoodCloseShot() {
    if (currentHoodPosition == HOODMEDIUMSHOTPOSITION || currentHoodPosition == HOODFARSHOTPOSITION) {
        switch(hoodMoveToCloseState) {
            case 0:
                hoodSolenoid->Set(true);
                hoodMoveOriginalTime = frc::Timer::GetFPGATimestamp();
                hoodMoveToCloseState++;
            break;
            case 1:
                if (frc::Timer::GetFPGATimestamp() - hoodMoveOriginalTime > 0.2_s) {
                    hoodMoveToCloseState++;
                }
            break;
            case 2:
                SetServoPosition(ServoCloseAndFarShotPosition); //position for holding medium shot
                hoodMoveOriginalTime = frc::Timer::GetFPGATimestamp();
                hoodMoveToCloseState++;
            break;
            case 3:
                if (frc::Timer::GetFPGATimestamp() - hoodMoveOriginalTime > 0.35_s) {
                    hoodMoveToCloseState++;
                }
            break;
            case 4:
                hoodSolenoid->Set(false);
                //hoodMoveToCloseState = 0;
                hoodMoveOriginalTime = frc::Timer::GetFPGATimestamp();
                hoodMoveToCloseState++;
            break;
            case 5:
                if (frc::Timer::GetFPGATimestamp() - hoodMoveOriginalTime > 0.2_s) {
                    currentHoodPosition = HOODCLOSESHOTPOSITION;
                    shooterPositionServo->SetDisabled();
                    hoodMoveToMediumState = 0;
                    hoodMoveToCloseState = 0;
					hoodMoveToFarState = 0;
                }
            break;
        }
    }
    /*else {
        SetServoPosition(ServoCloseAndFarShotPosition);
        hoodSolenoid->Set(false);
        hoodMoveToMediumState = 0; //reset this if we call medium shot again
        currentHoodPosition = HOODCLOSESHOTPOSITION;
    }*/
}
void Shooter::SetHoodMediumShot() {
	if (currentHoodPosition == HOODFARSHOTPOSITION) {
		SetServoPosition(ServoMediumShotPosition); //makes sure the servo is pushing against the shooter so it doesn't get pushed out of the way
	}
    if (currentHoodPosition != HOODMEDIUMSHOTPOSITION) {
        switch(hoodMoveToMediumState) {
            case 0:
                hoodSolenoid->Set(true);
                hoodMoveOriginalTime = frc::Timer::GetFPGATimestamp();
                hoodMoveToMediumState++;
            break;
            case 1:
                if (frc::Timer::GetFPGATimestamp() - hoodMoveOriginalTime > 0.3_s) {
                    hoodMoveToMediumState++;
                    
                }
            break;
            case 2:
                SetServoPosition(ServoMediumShotPosition); //position for holding medium shot
                hoodMoveOriginalTime = frc::Timer::GetFPGATimestamp();
                hoodMoveToMediumState++;
            break;
            case 3:
                if (frc::Timer::GetFPGATimestamp() - hoodMoveOriginalTime > 0.4_s) {
                    hoodMoveToMediumState++;
                    //shooterPositionServo->SetDisabled();
                    
                }
            break;
            case 4:
                hoodSolenoid->Set(false);
                hoodMoveToMediumState++;
                hoodMoveOriginalTime = frc::Timer::GetFPGATimestamp();
            break;
            case 5:
                if (frc::Timer::GetFPGATimestamp() - hoodMoveOriginalTime > 0.15_s) {
                    currentHoodPosition = HOODMEDIUMSHOTPOSITION;
                    //shooterPositionServo->SetDisabled();
                    hoodMoveToCloseState = 0;
					hoodMoveToFarState = 2;
                }
            break;
        }
    }
}
int Shooter::GetCurrentHoodPosition() {
    return currentHoodPosition;
}
void Shooter::ResetCurrentHoodPosition() { //only to be used in autonomous
    currentHoodPosition = HOODCLOSESHOTPOSITION;
}
double Shooter::GetCurrentRPM() {
    return shooterEncoder.GetVelocity();
}
double Shooter::CalcRPMFarShot(double currentLimeVertical) {
    return 4.2858 * currentLimeVertical * currentLimeVertical + 4.206434 * currentLimeVertical + 3650.6577; //3429 was 3429.6577 at waterloo day 1 was 3494.6577 at end of waterloo day 2 3470.6577 before dcmp
    //return 5100;
}
double Shooter::CalcRPMMediumShot(double currentLimeVertical) {
    return 2.36858 * currentLimeVertical * currentLimeVertical + -48.24201 * currentLimeVertical + 3639.9; //3439.9 was 3439.9 at waterloo day 1 was 3472.9 at end of waterloo day 2 //3516.9 before dcmp
}
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS


// Put methods for controlling this subsystem
// here. Call these from Commands.

