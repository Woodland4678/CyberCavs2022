// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "Subsystems/DriveTrain.h"
#include "Subsystems/PathFinder/Path.h"
#include <frc/SmartDashboard/SmartDashboard.h>
#include "networktables/NetworkTable.h"
#include "networktables/NetworkTableInstance.h"
#include <math.h>
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
#include "Commands/Drive.h"

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS
rev::CANSparkMax leftDriveLeaderMotor{3, rev::CANSparkMax::MotorType::kBrushless};


rev::CANSparkMax rightDriveLeaderMotor{5, rev::CANSparkMax::MotorType::kBrushless};


rev::CANSparkMax leftDriveFollowMotor{4, rev::CANSparkMax::MotorType::kBrushless};


rev::CANSparkMax rightDriveFollowMotor{6, rev::CANSparkMax::MotorType::kBrushless};
rev::SparkMaxPIDController leftDrivePidController = leftDriveLeaderMotor.GetPIDController();
rev::SparkMaxRelativeEncoder leftDriveEncoder = leftDriveLeaderMotor.GetEncoder();
rev::SparkMaxPIDController rightDrivePidController = rightDriveLeaderMotor.GetPIDController();
rev::SparkMaxRelativeEncoder rightDriveEncoder = rightDriveLeaderMotor.GetEncoder();

//RPM PID for NEO Motor
const double V_leftP = 0.000420; //0.000130
const double V_leftI = 1.05e-6;
const double V_leftD = 0.0;
const double V_leftF = 0.0;

const double V_rightP = 0.000420; //0.000130
const double V_rightI = 1.05e-6;
const double V_rightD = 0.0;
const double V_rightF = 0.0;

//Position PID for NEO Motors
const double P_leftP = 0.05;
const double P_leftI = 0;
const double P_leftD = 0;

const double P_rightP = 0.05;
const double P_rightI = 0;
const double P_rightD = 0;

const unsigned int CurrenLimit = 50;

const double SpeedConvert = (1 / 0.0009755068);// //0.0007563645

//Auto Constants
const double A_Time = 0.02;
const double A_Drivebase = 0.7112;

//Limelight
const double Lime_tower_h = 1.81864;
const double Lime_robot_angle = 26.51654413;

const double mAA_p = 0.40; //29
const double mAA_i = 0.01; //0.001
const double mAA_d = 0.03;
DriveTrain::DriveTrain() : frc::Subsystem("DriveTrain") {
    leftDrivePidController.SetP(V_leftP,0);
    leftDrivePidController.SetI(V_leftI,0);
    leftDrivePidController.SetD(V_leftD,0);
    leftDrivePidController.SetFF(V_leftF,0);
    rightDrivePidController.SetP(V_rightP,0);
    rightDrivePidController.SetI(V_rightI,0);
    rightDrivePidController.SetD(V_rightD,0);
    rightDrivePidController.SetFF(V_rightF,0);
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS



//shifter.reset(new frc::Solenoid(0, frc::PneumaticsModuleType::CTREPCM, 0));
shifter.reset(new frc::Relay(0));
AddChild("shifter", shifter);
leftDriveFollowMotor.Follow(leftDriveLeaderMotor);
rightDriveFollowMotor.Follow(rightDriveLeaderMotor);
limelight = nt::NetworkTableInstance::GetDefault().GetTable("limelight");
m_Gyro = new frc::ADXRS450_Gyro();
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

}

void DriveTrain::InitDefaultCommand() {
    // Set the default command for a subsystem here.
    // SetDefaultCommand(new MySpecialCommand());
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        SetDefaultCommand(new Drive());

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
}

void DriveTrain::Periodic() {
    frc::SmartDashboard::PutNumber("Gyro",(getGyroReading()*-1));

    frc::SmartDashboard::PutNumber("Left Position",getLeftEncoder());
    frc::SmartDashboard::PutNumber("Right Position",getRightEncoder());
    // Put code here to be run every loop
    ml_ValidTarget = limelight->GetNumber("tv",0.0);
    if(ml_ValidTarget){
        ml_targetHorizontial = limelight->GetNumber("tx",0.0);
        ml_targetVertical = limelight->GetNumber("ty",0.0);

        frc::SmartDashboard::PutNumber("Hor",ml_targetHorizontial);
        frc::SmartDashboard::PutNumber("Ver",ml_targetVertical);
    }

}
void DriveTrain::ShiftUp() {
    shifter->Set(frc::Relay::kReverse);
}
void DriveTrain::ShiftDown() {
    shifter->Set(frc::Relay::kForward);
}

double DriveTrain::getGyroReading(){
    return (m_Gyro->GetAngle()*-1);
}

void DriveTrain::resetGyro(){
    m_Gyro->Reset();
    thetaHeading = 0; // reset calculated heading as well.
}

void DriveTrain::calibrateGyro(){
    m_Gyro->Calibrate();
    thetaHeading = 0;
    positionX = 0;
    positionY = 0;
}

#pragma endregion

#pragma region Motor Low Level Control Functions
//------------------------------------------Set Functions------------------------------------------
void DriveTrain::setLeftRPM(double rpm){
    frc::SmartDashboard::PutNumber("Left Set Speed",-rpm);
    l_Set = -rpm;
    leftDrivePidController.SetReference(-rpm, rev::ControlType::kVelocity,0);
}

void DriveTrain::setRightRPM(double rpm){
    frc::SmartDashboard::PutNumber("Right Set Speed",rpm);
    r_Set = rpm;
    rightDrivePidController.SetReference(rpm, rev::ControlType::kVelocity,0);
}

void DriveTrain::setLeftVelocity(double mps){
    double rpm = mps * SpeedConvert;  // speed convert relates wheel diameter & gear ratio to speed
    setLeftRPM(rpm);
}

void DriveTrain::setRightVelocity(double mps){
    double rpm = mps * SpeedConvert;
    setRightRPM(rpm);
}

void DriveTrain::setLeftPosition(double encoder) {
    leftDrivePidController.SetReference(encoder,rev::ControlType::kPosition,1);
}

void DriveTrain::setRightPosition(double encoder) {
    rightDrivePidController.SetReference(encoder, rev::ControlType::kPosition,1);
}

void DriveTrain::SetRightPower(double pwr) {
    rightDriveLeaderMotor.Set(-pwr);
}
void DriveTrain::SetLeftPower(double pwr) {
    leftDriveLeaderMotor.Set(pwr);
}
void DriveTrain::resetEncoders()
    {
    leftDriveEncoder.SetPosition(0);
    rightDriveEncoder.SetPosition(0);
    }

void DriveTrain::resetPosition()
    {
    leftRef = leftDriveEncoder.GetPosition(); // Turns out there is not set/reset.  We'll need to subtract this reference value.
    rightRef = rightDriveEncoder.GetPosition();
    }

void DriveTrain::setStart(double x, double y, double angle)
    {
    positionX = x;
    positionY = y;
    thetaHeading = angle * M_PI / 180; // convert start angle to radians.
    prevEncLeft = leftDriveEncoder.GetPosition(); // Init left and right encoder previous positions to be ready
    prevEncRight = rightDriveEncoder.GetPosition(); // to measure any differences.
    }

#pragma endregion

#pragma region Motor Get Functions
//------------------------------------------Get Functions------------------------------------------
double DriveTrain::getLeftEncoder() {
   return  leftRef - leftDriveEncoder.GetPosition(); // reverse to get + reading for forward.
}

double DriveTrain::getRightEncoder() {
    return rightDriveEncoder.GetPosition() - rightRef;
}

//Returns RPM
double DriveTrain::getLeftRPM(){
    return leftDriveEncoder.GetVelocity();
}

double DriveTrain::getRightRPM(){
    return rightDriveEncoder.GetVelocity();
}

double DriveTrain::getLeftVelocity(){
    double rpm = leftDriveEncoder.GetVelocity();
    return rpm / SpeedConvert;
}

double DriveTrain::getRightVelocity(){
    double rpm = rightDriveEncoder.GetVelocity();
    return rpm / SpeedConvert;
}
#pragma endregion

#pragma region Limelight
//--------------------------------------------Limelight-----------------------------------------------
void DriveTrain::setLimeLED(bool state){
    if(state == 0)
        limelight->PutNumber("ledMode",1);//Turn off
    else
        limelight->PutNumber("ledMode",3);//Turn on
}

void DriveTrain::SetLimeFar(){
    limelight->PutNumber("pipeline", 0.0);
}

void DriveTrain::SetLimeZoomed(){
    limelight->PutNumber("pipeline", 1.0);
}


bool DriveTrain::getLimeValidObject(){
    return ml_ValidTarget; //Read in the periodic function 
}

double DriveTrain::getLimeHorizontial(){
    return ml_targetHorizontial;//Read in the periodic function
}

double DriveTrain::getLimeVertical(){
    return ml_targetVertical;//Read in the periodic function
}

double DriveTrain::calculateLimeDist(){
   if (ml_ValidTarget == true){
       return Lime_tower_h / (tan((ml_targetVertical + Lime_robot_angle) * M_PI / 180));
   } 
   return 0;
}
#pragma endregion

#pragma region Main Control Functions
//-----------------------------------------Advanced Controls------------------------------------------
bool DriveTrain::turnAmount(double degrees, int direction, double vel, double acc){
    if((mt_tarDeg != degrees) || (mt_tarDir != direction) || (mt_vel != vel))
        mt_state = 0;
    //frc::SmartDashboard::PutNumber("State",mt_state);
    switch(mt_state) {
        case 0:
            {
            mt_acc=acc;
            mt_vel=vel;
            mt_tarDeg=degrees;
            mt_tarDir=direction;

            double cycleTime = 1.0/50.0;
            double dist;
            
			//Calculate distance based on angle to move
			//wheel base = 0.545m
			//	PI * 0.545 = 360 degrees
			//	distance to move each wheel = pi * 0.545 * degrees / 360
			
			dist = (M_PI * 0.545 * degrees / 360) * 1.25;
			
            
            //Trapizodal Calculations
            double t1 = mt_vel / mt_vel, t2, t3;
            double d1 = 0.5 * mt_vel * (t1*t1), d2, d3 = d1;
            if(2*d1 > dist) { //No cruise
                d1 = dist / 2;
                d2 = 0;
                d3 = d1;
                t1 = sqrt(2 * d1 / mt_vel);
                t2 = t1;
                t3 = t2 + t1;
            }
            else {
                d2 = dist - 2 * d1;
                t2 = t1 + d2 / mt_vel;
                t3 = t2 + t1;
            }

            //Path generation of one wheel
            d[0] = 0;
            int i=0;
            
            for(double tcnt = 0;tcnt<t3;tcnt += cycleTime,i++) {
                if(tcnt < t1)
                    d[i] = 0.5 * mt_vel * (tcnt*tcnt);
                else if(tcnt < t2)
                    d[i] = d1 + (mt_vel * (tcnt-t1));
                else if(tcnt < t3)
                    d[i] = d1+d2+d3 - (0.5 * mt_vel * ((t3-tcnt)*(t3-tcnt)));
            }
            d[i++] = d1+d2+d3;
            mt_Cycles = i;
            printf("\nTURN: Run: cycles=%i",i);

            traverseCnt = 0;
            mt_state = 1;
            mt_OEncLeft = getLeftEncoder();
            mt_OEncRight = getRightEncoder();
            }
            break;
        case 1:
            //frc::SmartDashboard::PutNumber("cnt",traverseCnt);
            //frc::SmartDashboard::PutNumber("Total",mt_Cycles);
            if(traverseCnt >= mt_Cycles) {
                mt_state = 0;
                return true;
            }
            else {
                //Main path velocity
                double distance = d[traverseCnt];
                if(direction)
                    distance *= -1;
                double enDist = (distance * 20.81); //velocity is per second not per cycle
                //left wheel
                encLeft = enDist + mt_OEncLeft;
                encRight = enDist + mt_OEncRight;
                
                //printf("\nTURN: Cnt = %i | dist = %f | EncLeft = %f EncRight = %f",traverseCnt, distance, encLeft,encRight);
                setLeftPosition(encLeft);
                setRightPosition(encRight);
                traverseCnt++;
            }
            break;
    }
    return false;
}
double gyroError = 0;
bool DriveTrain::GyroTurn(double current, double turnAmount, double p, double i, double d, double allowError){
	static double past = 0;
	static double iValue = 0;
	static int counter = 0;
	// Never go more than 180 degrees in either direction with this function so make sure the step over 360 degrees is
	// handled correctly.  eg at 270 , go to 10 error = 10 - 270 = -260, error should be 370 - 270 = 100 (-260 + 360)
	// eg at 30 go to 300, error = 300 - 30 = 270, error should be 300 - 390 = -90 (270 - 360)
	// so, error of less than -180 needs to be adjusted by +360
	// error of more than +180 is adjusted by -360
	gyroError = turnAmount - current;
	if (gyroError < -180.0)
		gyroError += 360.0;
	if (gyroError > 180.0)
		gyroError -= 360.0;
	double pValue = p*gyroError;
	iValue += i*(gyroError);
	double dValue = d*(past - current);
	double totalValue = pValue + iValue + dValue;

	printf("Gyro: %f  tv = %f\n",current, totalValue);

	if(totalValue > 0.8)
		totalValue = 0.8;
	if(totalValue < -0.8)
		totalValue = -0.8;
	totalValue *= 0.65;
	SetRightPower(-totalValue);
	SetLeftPower(totalValue);


	past = current;
	if ((std::abs(gyroError) < allowError)||((fabs(totalValue) < 0.05)&&(fabs(gyroError) < allowError))) {
		counter++;
	} else {
		counter = 0;
	}
	if(counter >= 10){
		past = 0;
		iValue = 0;
		counter = 0;
		SetRightPower(0);
		SetLeftPower(0);
		return true;
	}
	return false;
}
void DriveTrain::initPath() {
    //pathState = 0;
}

bool DriveTrain::testPath() {
    /*switch(pathState) {
        case 0:
            //printf("\nStarting Path Weaving");
            m_Path->createNewPath();
            m_Path->addWayPoint(0.0,0.0,0.0);
            m_Path->addWayPoint(-2,-1,0); //2 meters x direction
            m_Path->addWayPoint(-4,-1,0); //2 meters x direction
            tCnt = 0;
            pTest = true;

            if(m_Path->makePath()) {
                m_Path->debug();
                resetGyro();
                //m_Path->startTraverse(frc::Timer::GetFPGATimestamp());
                pathState++;
            }
            else{
                pathState = 0;
                return true;
            }
            break;
        case 1:
            {
            if(!tCnt)
                m_Path->debug();
            //bool tdone = m_Path->traverse(frc::Timer::GetFPGATimestamp(),&rVel,&lVel,getGyroReading());
            setRightVelocity(rVel);
            setLeftVelocity(lVel);
            tCnt++;
            //if(tdone){
                setRightVelocity(0);
                setLeftVelocity(0);
                pathState = 2;
            //}
            }
            break;
        case 2://Reverse through the same path
            //Reset the timer
            //printf("\nStarting Path Weaving");
            m_Path->createNewPath();
            m_Path->addWayPoint(0.0,0.0,0.0);
            m_Path->addWayPoint(2,0,0); //2 meters x direction
            m_Path->addWayPoint(4,-1,0); //2 meters x direction
            tCnt = 0;
            pTest = true;

            if(m_Path->makePath()) {
                //m_Path->startTraverse(frc::Timer::GetFPGATimestamp());
                pathState++;
            }
            break;
        case 3:
            //inverse_traverse will run backwards
            //  Should end up in the same place it started assuming it ran throught the path forwards already
            //  Keep in mind the build up in error, so it could be off slightly
            bool tdone = m_Path->traverse(frc::Timer::GetFPGATimestamp(),&rVel,&lVel,getGyroReading());
            setRightVelocity(rVel);
            setLeftVelocity(lVel);
            tCnt++;
            //if(tdone){
                setRightVelocity(0);
                setLeftVelocity(0);
                pTest = true;
            //}
            return true;
            break;
    }
    return false;*/
}

//-------------------------------------------Auto Controls--------------------------------------------
double DriveTrain::autoAim(double target){
    double error = 0;
	static double past = 0;
	static double iValue = 0;
	//static int counter = 0;
	double current = ml_targetHorizontial;//Target position calculated in periodic function
    //TODO: If we lose the target, reset the I value

	error = (target / 30) - (current / 30); //Divided by 30 because that value is the maximum given the resolution of the camera
	double pValue = mAA_p*error;
    if(std::abs(error) < (2.0/30.0)){
	    iValue += (error);
    }
    else{
        iValue = 0;
    }
	double dValue = mAA_d*(past - current);
	double totalValue = pValue + (mAA_i*iValue) + dValue;

    printf("\nAA,%f,%f,%f,%f,%f",current,std::abs(error),pValue,iValue,totalValue);

	if(totalValue > 0.8)
		totalValue = 0.8;
	if(totalValue < -0.8)
		totalValue = -0.8;
	SetRightPower(-totalValue);
	SetLeftPower(totalValue);

	past = current;
	/*if ((std::abs(error) < 1.5)||((fabs(totalValue) < 0.1)&&(fabs(error) < 8))) {
		counter++;
	} else {
		counter = 0;
	}
	if(counter >= 10){
		past = 0;
		iValue = 0;
		counter = 0;
		setRightPower(0);
		setLeftPower(0);
		return true;
	}*/
	return error;
}
#pragma endregion


double DriveTrain::readPDPCurrent(int channel){
    //return pDP->GetCurrent(channel);
}

double DriveTrain::readTotalCurrent(){
    //return pDP->GetTotalCurrent();
}

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS


// Put methods for controlling this subsystem
// here. Call these from Commands.

