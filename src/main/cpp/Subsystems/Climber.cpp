// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "Subsystems/Climber.h"
#include <frc/Timer.h>
#include <frc/SmartDashboard/SmartDashboard.h>
#include "stdio.h"
#include "robot.h"

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS
//Climber positions
// double horizontalPosition = 0.0;
// double straightUpPosition = 86.09;
// double grabHighBarPosition = -56.5; //58.5
// // double swing1Position = 1.1588;
// double liftOffMediumBarPosition = 15.0;
// double swingToTraverseBarPosition = -240; // -259
// double grabTraverseBarPosition = -226.5;
// double finalSwingPosition = -169.5;
// double liftOffHighBarPosition = -150.0;

double horizontalPosition = 0.0;
double straightUpPosition = -86.09;
double grabHighBarPosition = 56.5; //58.5
// double swing1Position = 1.1588;
double liftOffMediumBarPosition = -15.0;
double swingToTraverseBarPosition = 240; // -259
double grabTraverseBarPosition = 226.5;
double finalSwingPosition = 169.5;
double liftOffHighBarPosition = 150.0;

#define DEFAULT_ACCEL 3000
#define DEFAULT_DECEL 3000
#define DEFAULT_MAX_SPEED 3000
#define DEFAULT_MIN_SPEED 250
// CalibrateAngle is 0 on the practice bot.  A +35 value causes the robot to not go straight up  (stops early)
// A negative value would cause the arm to move further than expected (beyond straight up at start)
// On the flight bot, angle will normally be up slightly so starting angle should be slightly positive (about 5.0 to 7.0)
#define CALIBRATEANGLE 3.5

// #define DEFAULT_ACCEL 5000
// #define DEFAULT_DECEL 5000
// #define DEFAULT_MAX_SPEED 5000
// #define DEFAULT_MIN_SPEED 250


double positionIncrementForSlowMovement = 0.05; //When we want to move the arm against the bar we will keep increasing its target position by this much

double climberMotorAllowedError = 3;

int climbState,climbSubState,climbVelocityState;
int inDeceleration;
FILE *fpt;

auto delayForDetectingBar = 1_s; //how many counts we need to see the bar for before we move on in seconds
auto delayForPneumaticMovement = 1_s; //time delay to allow the pneumatics to move in seconds
auto delayForMotorMovement = 1_s;


auto originalTime = 0_s;
auto timeOut = 0_s;

// Code to optimize the climb.
// Rather than position control, let's go with velocity control of the Spark Max / Neo Motor system.
// We're going to implement a forward/reverse climb that will allow the operator to climb in the upward direction and also downwards.
// It may be advantageous to also allow the operator to perform a climb reset which will assume the robot has been dislodges from the climb
// and needs to start from step 1 (or 2).  Most likely, the climber air cylinder will be in the up position.
// We'll want to disable climbing motor movement if the air pressure is not present.
// We can probably use the same states as the original climb sequence.
// void Climber::ClimbUp(){ will be called at 50Hz while a button is held to climb in the upward direction.
// void Climber::ClimbDown(){ will be called at 50Hz while a button is held to climb in the downward direction.
// When neither is pressed, we're expecting a call to a process that will bring the climber motor to a controlled stop
// Velocity will normally be changed quite gently in order to minimize the swing that may be experienced by sudden changes in velocity.
// We are going to use a few global values to manage motor speed
double thisTime,lastTime,diffTime;
double climbVelocity; // This is the target velocity of the climber (may be negative)
double timeToTarget, timeToDecel;
double originalPosition; // Used to make sure we're adjusting velocity in the correct direction.
double climbMinVelocity,climbMaxVelocity;
double timeToDecl;
double climbDecel,climbAccel;
double climbTargetPosition;


rev::CANSparkMax climberLeaderMotor{7, rev::CANSparkMax::MotorType::kBrushless};
rev::CANSparkMax climberFollowerMotor{9, rev::CANSparkMax::MotorType::kBrushless};
rev::SparkMaxPIDController climberPidController = climberLeaderMotor.GetPIDController();
rev::SparkMaxRelativeEncoder climberEncoder = climberLeaderMotor.GetEncoder();
Climber::Climber() : frc::Subsystem("Climber") {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS




//AddChild("heightSolenoid", heightSolenoid);


AddChild("reachSolenoid", reachSolenoid);


AddChild("LockSolenoid", lockSolenoid);

calibrateLimit.reset(new frc::DigitalInput(5));
AddChild("calibrateLimit", calibrateLimit);

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    climberFollowerMotor.Follow(climberLeaderMotor);
    climberPidController.SetP(0.00025);
    climberPidController.SetI(0.000001);
    climberPidController.SetD(0);
    climberPidController.SetFF(0);
    climberPidController.SetOutputRange(-1.0, 1.0);

//    climberPidController.SetP(0.075);
//    climberPidController.SetI(0);
//    climberPidController.SetD(0);
//    climberPidController.SetOutputRange(-0.85, 0.85);
}

void Climber::InitDefaultCommand() {
    // Set the default command for a subsystem here.
    // SetDefaultCommand(new MySpecialCommand());
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
}

void Climber::Periodic() {
    // Put code here to be run every loop

}
void Climber::SetClimberPower(double pwr) {
    //climberPidController.SetReference(pwr, rev::ControlType::kVelocity);
    climberLeaderMotor.Set(pwr);
}

void Climber::SetClimberVelocity(double vel) {
    climberPidController.SetReference(vel, rev::ControlType::kVelocity);
}

void Climber::IncreaseClimbState() {
    climbState++;
}

bool isClicked = true;

bool Climber::CalibrateClimber(){
    if (!calibrateLimit->Get() &&isClicked){
        SetClimberVelocity(-500);
    }

    else if(calibrateLimit->Get()){
        SetClimberVelocity(500);
        isClicked=false;
    }else{
        climberEncoder.SetPosition(CALIBRATEANGLE);
        isClicked = true;
        climberLeaderMotor.StopMotor();
        return true;
    }

    return false;
}


void Climber::SetClimberPosition(double position){
    climberPidController.SetReference(position, rev::ControlType::kPosition);
}

double Climber::GetClimberPosition(){ 
    return(climberEncoder.GetPosition());
}

double Climber::GetClimberSpeed(){ 
    return(climberEncoder.GetVelocity());
}

void Climber::ExtendReachingArm(){
    reachSolenoid.Set(frc::DoubleSolenoid::Value::kReverse); // Red Wire
}

void Climber::RetractReachingArm(){
     reachSolenoid.Set(frc::DoubleSolenoid::Value::kForward); // Green Wire
}

void Climber::Lock(){
     lockSolenoid.Set(frc::DoubleSolenoid::Value::kReverse); // Black Wire
}

void Climber::Unlock(){
     lockSolenoid.Set(frc::DoubleSolenoid::Value::kForward); // White Wire
}

void Climber::RaiseClimber(){
    // heightSolenoid.Set(frc::DoubleSolenoid::Value::kForward);
}

void Climber::LowerClimber(){
    // heightSolenoid.Set(frc::DoubleSolenoid::Value::kReverse);
}

/*
enum {
    CLIMBINGSETUP,
    DRIVINGTOBAR,
    GRABHIGHBAR,
    ENSUREHIGHBAR,
    SWING1,
    LIFTOFFMIDBAR,
    MOVETOTRAVERSEBAR,
    GRABTRAVERSEBAR,
    ENSUREGRABTRAVERSEBAR,
    SWING2,
    LIFTOFFHIGHBAR
};
*/

void Climber::OpenFile()
    {
    fpt = fopen("/media/sda1/test.txt","w"); // Open file for logging.
    }

void Climber::CloseFile()
    {
    fputs("The End\n",fpt);
    fclose(fpt);
    climbState = 0;
    }

int climbCount = 0;
int prevpov = -1;
void Climber::Climb(){

// When climb is activated, do the homing thing.  This should probably happen when robot is first activated in auto.    
// Checking POV here to determine what to do.  -1 if no buttons are pressed (controlled stop)
// 0 if Up, 180 if Down
// 270 Left (exit)
// 90 Can be used for immediate stop.

//    climbCount++;
// fprintf(fpt,"climbing state = %d, POV=%d\n",climbState,Robot::oi->getDriverGamepad()->GetPOV());
//    frc::SmartDashboard::PutNumber("climb count", climbState);
    int pov;
    if (Robot::oi->getOperatorGamepad()->GetRawButton(4)) {
        pov = 0;
    }
    else if (Robot::oi->getOperatorGamepad()->GetRawButton(2)) {
        pov = 180;
    }
    else if (Robot::oi->getOperatorGamepad()->GetRawButton(3)) {
        pov = 270;
    }
    //pov = Robot::oi->getDriverGamepad()->GetPOV();
    if (prevpov != pov)
        {
        fprintf(fpt,"POV Change %d to %d\n",prevpov,pov);
        }
switch(climbState)
    {
    case 0: // Go to vertical position
        climbAccel = DEFAULT_ACCEL; // 10000
        climbDecel = DEFAULT_DECEL; // 10000
        climbMaxVelocity = DEFAULT_MAX_SPEED; // 6000
        climbMinVelocity = DEFAULT_MIN_SPEED;
        climbTargetPosition = straightUpPosition;
        ExtendReachingArm();
        if (!adjustVelocity()) // Make speed adjustments according to the global parameters
            {
            SetClimberVelocity(climbVelocity);
            }
        else
            {
            originalPosition = GetClimberPosition(); // Assign originalPosition to current position when nothing pressed.
            climberLeaderMotor.StopMotor(); // Make sure motor stops when we get to target.
            climbSubState = VERTICALTOFROMMIDBAR; // We're at position, move on.
            }
        break;
    case 1: // We have calibrate point.  Read to climb up (or down)
        if (pov == 0) // Up button held
            {
            switch(climbSubState)
                {
                case HORIZONTALTOFROMVERTICAL: // In this state, up will move to the climb start position
                    climbSubState = VERTICALTOFROMMIDBAR;
                    break;
                    // climbAccel = DEFAULT_ACCEL; // 10000
                    // climbDecel = DEFAULT_DECEL; // 10000
                    // climbMaxVelocity = DEFAULT_MAX_SPEED; // 6000
                    // climbMinVelocity = DEFAULT_MIN_SPEED;
                    // climbTargetPosition = straightUpPosition;
                    // ExtendReachingArm();
                    // if (!adjustVelocity()) // Make speed adjustments according to the global parameters
                    //     {
                    //     SetClimberVelocity(climbVelocity);
                    //     }
                    // else
                    //     {
                    //     originalPosition = GetClimberPosition(); // Assign originalPosition to current position when nothing pressed.
                    //     climberLeaderMotor.StopMotor(); // Make sure motor stops when we get to target.
                    //     climbSubState = VERTICALTOFROMMIDBAR; // We're at position, move on.
                    //     }
                    // break;
                case VERTICALTOFROMMIDBAR: // Do the initial lift to near or at the position for lock.
                    climbAccel = DEFAULT_ACCEL; // 6000
                    climbDecel = DEFAULT_DECEL; // 6000
                    climbMaxVelocity = DEFAULT_MAX_SPEED; // 6000
                    climbMinVelocity = DEFAULT_MIN_SPEED;
                    climbTargetPosition = grabHighBarPosition;
                    if (!adjustVelocity()) // Make speed adjustments according to the global parameters
                        {
                        SetClimberVelocity(climbVelocity);
                        }
                    else
                        {
                        originalPosition = GetClimberPosition(); // Assign originalPosition to current position when nothing pressed.
                        climberLeaderMotor.StopMotor(); // Make sure motor stops when we get to target.
                        climbSubState = MIDBARTOFROMLOCKPOS; // We're at position, move on.
                        }
                    break;
                case MIDBARTOFROMLOCKPOS:
                    // Gentle move in to the position for locking - check sensor (if it's connected) and do the lock.
                    Lock();
                    climbSubState = LOCKPOSTOFROMRETRACT;
                    break;
                case LOCKPOSTOFROMRETRACT:  // Lift claw from bar to point where we can retract.
                    climbAccel = DEFAULT_ACCEL;
                    climbDecel = DEFAULT_DECEL;
                    climbMaxVelocity = DEFAULT_MAX_SPEED; // 6000
                    climbMinVelocity = DEFAULT_MIN_SPEED;
                    climbTargetPosition = liftOffMediumBarPosition;
                    if (!adjustVelocity()) // Make speed adjustments according to the global parameters
                        {
                        SetClimberVelocity(climbVelocity);
                        }
                    else
                        {
                        originalPosition = GetClimberPosition(); // Assign originalPosition to current position when nothing pressed.
                        climberLeaderMotor.StopMotor(); // Make sure motor stops when we get to target.
                        climbSubState = RETRACTCLAW; // We're at position, move on.
                        }
                    break;
                case RETRACTCLAW: // Retract Claw
                    RetractReachingArm();
                    climbSubState = RETRACTTOFROMEXTEND;
                    break;
                case RETRACTTOFROMEXTEND: // Long Swing all the way to bring claw above traverse bar. -243.5
                    climbAccel = DEFAULT_ACCEL;
                    climbDecel =  DEFAULT_DECEL; // 3000
                    climbMaxVelocity =  DEFAULT_MAX_SPEED; // 6000
                    climbMinVelocity = DEFAULT_MIN_SPEED;
                    climbTargetPosition = swingToTraverseBarPosition;
                    if (!adjustVelocity()) // Make speed adjustments according to the global parameters
                        {
                        SetClimberVelocity(climbVelocity);
                        }
                    else
                        {
                        originalPosition = GetClimberPosition(); // Assign originalPosition to current position when nothing pressed.
                        climberLeaderMotor.StopMotor(); // Make sure motor stops when we get to target.
                        climbSubState = EXTENDCLAW; // We're at position, move on.
                        }
                    break;
                case EXTENDCLAW: // should now be able to extend the claw and unlock
                    ExtendReachingArm();
                    Unlock();
                    climbSubState = EXTENDTOFROMTRAVERSE;
                    break;
                case EXTENDTOFROMTRAVERSE: // Lower on to Traverse Bar -226.5
                    climbAccel = DEFAULT_ACCEL;
                    climbDecel = DEFAULT_DECEL;
                    climbMaxVelocity = DEFAULT_MAX_SPEED;
                    climbMinVelocity = DEFAULT_MIN_SPEED;
                    climbTargetPosition = grabTraverseBarPosition;
                    if (!adjustVelocity()) // Make speed adjustments according to the global parameters
                        {
                        SetClimberVelocity(climbVelocity);
                        }
                    else
                        {
                        originalPosition = GetClimberPosition(); // Assign originalPosition to current position when nothing pressed.
                        climberLeaderMotor.StopMotor(); // Make sure motor stops when we get to target.
                        climbSubState = TRAVERSETOFROMFINAL; // We're at position, move on.
                        }
                    break;
                case TRAVERSETOFROMFINAL: // Lift off high bar -139.5
                    climbAccel = DEFAULT_ACCEL; // 3000
                    climbDecel = DEFAULT_DECEL; // 3000
                    climbMaxVelocity = DEFAULT_MAX_SPEED; // 3500
                    climbMinVelocity = DEFAULT_MIN_SPEED;
                    climbTargetPosition = liftOffHighBarPosition;
                    if (!adjustVelocity()) // Make speed adjustments according to the global parameters
                        {
                        SetClimberVelocity(climbVelocity);
                        }
                    else
                        {
                        originalPosition = GetClimberPosition(); // Assign originalPosition to current position when nothing pressed.
                        climberLeaderMotor.StopMotor(); // Make sure motor stops when we get to target.
                        climbSubState = ENDOFCLIMB; // We're at position, move on.
                        }
                    break;
                case ENDOFCLIMB: // Climb is done.  Reverse is still allowed though.
                    break;
                }   

            }
        else if (pov == 180)
            { // Down held
            switch(climbSubState)
                {
                case HORIZONTALTOFROMVERTICAL: // In this state, up will move to the climb start position - probably not a good idea if the bar is still right there.
                    // if (GetClimberPosition() < 0) // If we're not at horizontal yet, move there.
                    //     {
                    //     climbAccel = 6000;
                    //     climbDecel = 6000;
                    //     climbMaxVelocity = 6000;
                    //     climbMinVelocity = 500;
                    //     climbTargetPosition = horizontalPosition;
                    //     ExtendReachingArm(); // 
                    //     if (!adjustVelocity()) // Make speed adjustments according to the global parameters
                    //         {
                    //         SetClimberVelocity(climbVelocity);
                    //         }
                    //     else
                    //         {
                    //         originalPosition = GetClimberPosition(); // Assign originalPosition to current position when nothing pressed.
                    //         climberLeaderMotor.StopMotor(); // Make sure motor stops when we get to target.
                    //         climbSubState = VERTICALTOFROMMIDBAR; // We're at position, move on.
                    //         }
                    //     }
                    // else
                    //     {
                    //     climberLeaderMotor.StopMotor(); // If we've gone to (or just past) horizontal.  Do a stop at this location.
                    //     originalPosition = GetClimberPosition(); // Assign originalPosition to current position when nothing pressed.
                    //     }
                    break;
                case VERTICALTOFROMMIDBAR: // going back down from lock position to vertical - basically setting the robot back down on the ground.
                    climbAccel = DEFAULT_ACCEL;
                    climbDecel = DEFAULT_DECEL;
                    climbMaxVelocity = DEFAULT_MAX_SPEED;
                    climbMinVelocity = DEFAULT_MIN_SPEED; // 500
                    climbTargetPosition = straightUpPosition;
                    if (!adjustVelocity()) // Make speed adjustments according to the global parameters
                        {
                        SetClimberVelocity(climbVelocity);
                        }
                    else
                        {
                        originalPosition = GetClimberPosition(); // Assign originalPosition to current position when nothing pressed.
                        climberLeaderMotor.StopMotor(); // Make sure motor stops when we get to target.
                        climbSubState = HORIZONTALTOFROMVERTICAL; // We're at position, move on.
                        }
                    break;
                case MIDBARTOFROMLOCKPOS: // Up would have locked at this point we need to unlock to undo that.
                    // May need to move a bit to ensure we're in good contact with the bar for release of the lock.
                    Unlock();
                    climbSubState = VERTICALTOFROMMIDBAR; // move down a state to begin lowering robot to the ground.
                    break;
                case LOCKPOSTOFROMRETRACT: // This would be moving from where the claw was retracted back on to the mid bar so we can release the lock.
                    climbAccel = DEFAULT_ACCEL;
                    climbDecel = DEFAULT_DECEL;
                    climbMaxVelocity = DEFAULT_MAX_SPEED;
                    climbMinVelocity = DEFAULT_MIN_SPEED; // 500;
                    climbTargetPosition = grabHighBarPosition;
                    if (!adjustVelocity()) // Make speed adjustments according to the global parameters
                        {
                        SetClimberVelocity(climbVelocity);
                        }
                    else
                        {
                        originalPosition = GetClimberPosition(); // Assign originalPosition to current position when nothing pressed.
                        climberLeaderMotor.StopMotor(); // Make sure motor stops when we get to target.
                        climbSubState = MIDBARTOFROMLOCKPOS; // We're at position, move on.
                        }
                    break;
                case RETRACTCLAW: // claw will be just above mid bar.  Time to extend it now actually.
                    ExtendReachingArm();
                    climbSubState = LOCKPOSTOFROMRETRACT;
                    break;
                case RETRACTTOFROMEXTEND: // This is the big long swing from above the traverse bar to above the mid bar.
                    climbAccel = DEFAULT_ACCEL;
                    climbDecel = DEFAULT_DECEL;
                    climbMaxVelocity = DEFAULT_MAX_SPEED;
                    climbMinVelocity = DEFAULT_MIN_SPEED; // 500;
                    climbTargetPosition = liftOffMediumBarPosition;
                    if (!adjustVelocity()) // Make speed adjustments according to the global parameters
                        {
                        SetClimberVelocity(climbVelocity);
                        }
                    else
                        {
                        originalPosition = GetClimberPosition(); // Assign originalPosition to current position when nothing pressed.
                        climberLeaderMotor.StopMotor(); // Make sure motor stops when we get to target.
                        climbSubState = RETRACTCLAW; // We're at position, move on.
                        }
                    break;
                case EXTENDCLAW: // This will actually now be a retract claw.
                    RetractReachingArm();
                    Lock(); // Also good time to re-lock the locking arm part since we should be sitting on the high bar with it.
                    climbSubState = RETRACTTOFROMEXTEND;
                    break;
                case EXTENDTOFROMTRAVERSE: // do motion to lift claw off of the traverse bar.
                    climbAccel = DEFAULT_ACCEL;
                    climbDecel = DEFAULT_DECEL; // 3500
                    climbMaxVelocity = DEFAULT_MAX_SPEED;
                    climbMinVelocity = DEFAULT_MIN_SPEED; // 500;
                    climbTargetPosition = swingToTraverseBarPosition; //  - 5.0;
                    if (!adjustVelocity()) // Make speed adjustments according to the global parameters
                        {
                        SetClimberVelocity(climbVelocity);
                        }
                    else
                        {
                        originalPosition = GetClimberPosition(); // Assign originalPosition to current position when nothing pressed.
                        climberLeaderMotor.StopMotor(); // Make sure motor stops when we get to target.
                        climbSubState = EXTENDCLAW; // We're at position, move on.
                        }
                    break;
                case TRAVERSETOFROMFINAL: // do motion to bring locking arm back down on to high bar
                    ExtendReachingArm();
                    Unlock();
                    climbSubState = EXTENDTOFROMTRAVERSE;
                    break;
                case ENDOFCLIMB: // From End of climb, lower locking claw back down on to the high bar
                    climbAccel = DEFAULT_ACCEL;
                    climbDecel = DEFAULT_DECEL;
                    climbMaxVelocity = DEFAULT_MAX_SPEED;
                    climbMinVelocity = DEFAULT_MIN_SPEED; // 500;
                    climbTargetPosition = grabTraverseBarPosition;
                    if (!adjustVelocity()) // Make speed adjustments according to the global parameters
                        {
                        SetClimberVelocity(climbVelocity);
                        }
                    else
                        {
                        originalPosition = GetClimberPosition(); // Assign originalPosition to current position when nothing pressed.
                        climberLeaderMotor.StopMotor(); // Make sure motor stops when we get to target.
                        climbSubState = TRAVERSETOFROMFINAL; // We're at position, move on.
                        }
                    break;
                }
            }
        else if (pov == 270)
            { // This is a sudden stop and reset
            climberLeaderMotor.StopMotor();
            climbState = 2; // Go to State 2
            climbSubState = 0; // Reset this to 0 just in case.  Basically allow climb to resume from the very beginning.
            }
        else // Neither up, nor down, do controlled deceleration
            { // pressing up or down will simply resume where we left off.
            if (prevpov != pov) // If just released, indicate we are in a gentle decel state.
                {
                inDeceleration = 1; // Indicate we are in a deceleration event
                climbDecel = 10000; // Do a fairly fast decelerate.  We typically want to stop fairly quickly.
                }
            if (gentleDecel())
                {
                originalPosition = GetClimberPosition(); // Assign originalPosition to current position when nothing pressed.
                inDeceleration = 0; // No longer in a deceleration event
//                climbSubState = 0;
//                climbState = 2; // Controlled stop is complete.  Go to state 2.
                }
            else
                {
                if (inDeceleration)
                    SetClimberVelocity(climbVelocity);
                else
                    climberLeaderMotor.StopMotor(); // Make sure motor stops.
                }
            }
            
    //     if (pov == 0)
    //         {
    //         climbAccel = 6000; // 1425.9 * 3;
    //         climbDecel = 6000; // 1425.9 * 3;
    //         climbMaxVelocity = 6000; // 713 * 3;
    //         climbMinVelocity = 500;
    //         climbTargetPosition = 86.09; // Straight up is the target
    //         climbState++;            
    //         }
    //     break;
    //     case 2: // while pov is held at 0, 
    // case 1: // Begin responding to POV to start the climb.
    //     // Adjust position to -86.09
    //     if (pov == 0)
    //         {
    //         climbAccel = 6000; // 1425.9 * 3;
    //         climbDecel = 6000; // 1425.9 * 3;
    //         climbMaxVelocity = 6000; // 713 * 3;
    //         climbMinVelocity = 500;
    //         climbTargetPosition = 86.09;
    //         if (!adjustVelocity()) // Make speed adjustments according to the global parameters
    //             SetClimberVelocity(climbVelocity);
    //         else
    //             climbState++;
    //         }
    //     else if (pov == 180)
    //         {
    //         climbAccel = 6000;
    //         climbDecel = 2000;
    //         climbMaxVelocity = 6000;
    //         climbMinVelocity = 500;
    //         climbTargetPosition = 0;
    //         if (!adjustVelocity()) // Make speed adjustments according to the global parameters
    //             SetClimberVelocity(climbVelocity);
    //         else
    //             climbState++;
    //         }
    //     else if (pov == -1) // No buttons pressed
    //         {
    //         climberLeaderMotor.StopMotor(); // Make sure motor stops when we let go of POV.
    //         originalPosition = GetClimberPosition(); // Assign originalPosition to current position when nothing pressed.
    //         climbVelocity = 0; // set velocity at 0 since we've told the motors to stop
    //         }
    //     if (pov == 90) // Go try out the air cylinders
    //         climbState = 4;
    //     break;
    // case 2: // Stop
    //     climberLeaderMotor.StopMotor();
    //     if (pov == -1)
    //         climbState = 1; // Allow up and down back and forth
    //     break;
    // case 4: // Try retract of claw
    //     if (pov == 90)
    //         {
    //         RetractReachingArm();
    //         climbState++;
    //         }
    //     break;
    // case 5:
    //     if (pov == -1)
    //         climbState++;
    //     break;
    // case 6: // Try extend of claw
    //     if (pov == 90)
    //         {
    //         ExtendReachingArm();
    //         climbState++;
    //         }
    //     break;
    // case 7:
    //     if (pov == -1)
    //         climbState++;
    //     break;
    // case 8: // Try lock
    //     if (pov == 90)
    //         {
    //         Lock();
    //         climbState++;
    //         }
    //     break;
    // case 9: 
    //     if (pov == -1)
    //         climbState++;
    //     break;
    // case 10: // And unlock
    //     if (pov == 90)
    //         {
    //         Unlock();
    //         climbState++;
    //         }
    //     break;
    // case 11:
    //     if (pov == -1)
    //         climbState = 1;
    //     break;

    prevpov = pov;
    }

//    switch (climbState){
//         case CLIMBINGSETUP:
//             RaiseClimber();
//             SetClimberPosition(straightUpPosition);

//             if (!(abs(climberEncoder.GetPosition() - straightUpPosition) < climberMotorAllowedError)){
//                 originalTime = frc::Timer::GetFPGATimestamp();
//             }
//             if ((frc::Timer::GetFPGATimestamp() - originalTime) >= delayForMotorMovement){
//                 climbState=DRIVINGTOBAR;
//                 timeOut = frc::Timer::GetFPGATimestamp();
//             }

//             ExtendReachingArm();
//             Unlock();

//             break;

//         case DRIVINGTOBAR:
//             // drivebase: drive backward
            
//             /*if (reachLimit1.Get() == true){ //if we do not see the bar keep resetting originalTime
//                 originalTime = frc::Timer::GetFPGATimestamp();
//             }*/
//             if ((frc::Timer::GetFPGATimestamp() - originalTime)>=delayForDetectingBar){
//                 climbState=GRABHIGHBAR;
//             }

//             ///
//             if (frc::Timer::GetFPGATimestamp() - timeOut > 5_s) {
//                 climbState=GRABHIGHBAR;
//                 timeOut = frc::Timer::GetFPGATimestamp();
//             }
//             break;

//         case GRABHIGHBAR:
//             SetClimberPosition(grabHighBarPosition);

//             if (!(abs(climberEncoder.GetPosition() - grabHighBarPosition) < climberMotorAllowedError)){
//                 originalTime = frc::Timer::GetFPGATimestamp();
//             }
//             if ((frc::Timer::GetFPGATimestamp() - originalTime) >= delayForMotorMovement){
//                 climbState=ENSUREHIGHBAR;
//                 timeOut = frc::Timer::GetFPGATimestamp();
//             }
//             break;
        
//         case ENSUREHIGHBAR:
//             grabHighBarPosition += positionIncrementForSlowMovement;
//             SetClimberPosition(grabHighBarPosition);

//            /* if (lockLimit.Get() == true){
//                 originalTime = frc::Timer::GetFPGATimestamp();
//             }*/

//             if ((frc::Timer::GetFPGATimestamp() - originalTime)>=delayForDetectingBar){      
//                 Lock();
//             }

//             if ((frc::Timer::GetFPGATimestamp() - originalTime)>=delayForDetectingBar+delayForPneumaticMovement){
//                 climbState=SWING1;
//                 timeOut = frc::Timer::GetFPGATimestamp();
//             }

//             // Temporary code
//             if (frc::Timer::GetFPGATimestamp() - timeOut > 3_s) {
//                 Lock();
//             }
            
//             //
//             if (frc::Timer::GetFPGATimestamp() - timeOut > 4_s) {
//                 climbState=SWING1;
//                 timeOut = frc::Timer::GetFPGATimestamp();
//             }
//             break;

//         case SWING1: // swing
//             SetClimberPosition(swing1Position); // need to find the position
//             if (!(abs(climberEncoder.GetPosition() - swing1Position) < climberMotorAllowedError)){
//                 originalTime = frc::Timer::GetFPGATimestamp();
//             }

//             if ((frc::Timer::GetFPGATimestamp() - originalTime) >= delayForMotorMovement){
//                 climbState=LIFTOFFMIDBAR;
//                 timeOut = frc::Timer::GetFPGATimestamp();
//             }
//             break;
        
//         case LIFTOFFMIDBAR: // lifting off the bar
//             SetClimberPosition(liftOffMediumBarPosition); // need to find the position
            
//             if (!(abs(climberEncoder.GetPosition() - liftOffMediumBarPosition) < climberMotorAllowedError)){
//                 originalTime = frc::Timer::GetFPGATimestamp();  
//             }

//             if ((frc::Timer::GetFPGATimestamp() - originalTime) >= delayForMotorMovement){
//                 RetractReachingArm(); 
//             }

//             if ((frc::Timer::GetFPGATimestamp() - originalTime) >= (delayForDetectingBar+delayForPneumaticMovement)){
//                 climbState=MOVETOTRAVERSEBAR;
//                 timeOut = frc::Timer::GetFPGATimestamp();
//             }
//             break;
        
//         case MOVETOTRAVERSEBAR:
//             SetClimberPosition(swingToTraverseBarPosition); // find the position

//             if (!(abs(climberEncoder.GetPosition() - swingToTraverseBarPosition) < climberMotorAllowedError)){
//                 originalTime = frc::Timer::GetFPGATimestamp();    
//             }

//             if ((frc::Timer::GetFPGATimestamp() - originalTime) >= delayForMotorMovement){
//                 ExtendReachingArm();
//             }

//             if ((frc::Timer::GetFPGATimestamp() - originalTime)>=delayForDetectingBar+delayForPneumaticMovement){
//                 climbState=GRABTRAVERSEBAR;
//                 timeOut = frc::Timer::GetFPGATimestamp();
//             }
//             break;

//         case GRABTRAVERSEBAR:
//             SetClimberPosition(grabTraverseBarPosition);

//             if (!(abs(climberEncoder.GetPosition() - grabTraverseBarPosition) < climberMotorAllowedError)){
//                 originalTime = frc::Timer::GetFPGATimestamp();      
//             }

//             if ((frc::Timer::GetFPGATimestamp() - originalTime) >= delayForMotorMovement){
//                 climbState=ENSUREGRABTRAVERSEBAR;
//                 timeOut = frc::Timer::GetFPGATimestamp();
//             }
//             break;

//         case ENSUREGRABTRAVERSEBAR:
//             grabTraverseBarPosition -= positionIncrementForSlowMovement;
//             SetClimberPosition(grabTraverseBarPosition);
//             /*if (reachLimit2.Get() == true){
//                 originalTime = frc::Timer::GetFPGATimestamp();  
//             }*/     
//             if ((frc::Timer::GetFPGATimestamp() - originalTime) >= delayForMotorMovement){
//                 climbState=SWING2;
//                 timeOut = frc::Timer::GetFPGATimestamp();
//                 Unlock();
//             }


//             // Temporary code
//             if (frc::Timer::GetFPGATimestamp() - timeOut > 2_s) {
//                 Unlock();
//             }
            
//             if (frc::Timer::GetFPGATimestamp() - timeOut > 3_s) {
//                 climbState=SWING2;
//                 timeOut = frc::Timer::GetFPGATimestamp();
//             }
//             break;

//         case SWING2: // second swing
//             SetClimberPosition(finalSwingPosition); // need to find the position
            
//             if (!(abs(climberEncoder.GetPosition() - finalSwingPosition) < climberMotorAllowedError)){   
//                 originalTime = frc::Timer::GetFPGATimestamp();    
//             }

//             if ((frc::Timer::GetFPGATimestamp() - originalTime) >= delayForMotorMovement){
//                 Unlock();
//             }

//             if ((frc::Timer::GetFPGATimestamp() - originalTime)>=delayForDetectingBar+delayForPneumaticMovement){
//                 climbState=LIFTOFFHIGHBAR;
//                 timeOut = frc::Timer::GetFPGATimestamp();
//             }

//             // Temporary code
//             if (frc::Timer::GetFPGATimestamp() - timeOut > 5_s) {
//                 climbState=LIFTOFFHIGHBAR;
//                 timeOut = frc::Timer::GetFPGATimestamp();
//             }
//             break;

//         case LIFTOFFHIGHBAR:
//             SetClimberPosition(liftOffHighBarPosition); // find the position
//             break;

//     }
}

bool Climber::adjustVelocity() // Make speed adjustments according to the global parameters
    {
    int rval; // Returns true when the target has been reached.
    double direction; // multiplier used to get the sign right.

    rval = 0; // return False by default.
    thisTime = (double)frc::Timer::GetFPGATimestamp(); // Use FPGATime just in case some execution cycles are missed.
    diffTime = thisTime - lastTime; // will usually be 0.02 (1/50 sec) but it may sometimes be 0.04 or 0.06 if cycles are missed.
    if (diffTime > 0.10) // If we miss more than 5 time slices - or this is that start-up, set diffTime at 0.02
        { // First time through, diffTime will be quite a bit more thn 0.05 (normally)
        diffTime = 0.02; // Make sure we don't use some crazy high diffTime value.  That would cause problems.
        }
    lastTime = thisTime;
    if (climbTargetPosition > originalPosition)
        direction = 1;
    else if (climbTargetPosition < originalPosition)
        direction = -1;
    else
        direction = 0; // Target matches Original.  There's actually no reason to move at all.
    if (climbVelocityState == 0) // If we're still in the accelerate / maintain max velocity mode, do that.
        {
        // Accelerating / maintain max velocity.
        // Do a quick check to see if we need to skip Maintain Max Velocity and go directly to decelerate.
        // V2 = V1 + at, t = (V2 - V1) / a
        // Also need to calculate how long we need to reach our TargetPosition.  d = 1/2(V1 + V2)t, t = 2d/(V1 + V2)
        // easiest formula for that is t = 2d / (V1 + V2)
        // Check distance left to go given current velocity and final velocity
        // Velocity is in RPM.  Position is NOT rotations.  It's 42 counts per revolution, then we have the gearing.
        // We really don't need to worry about this velocity profile ever changing direction.  We'll come to a stop in the states before making a direction change.
        // 
        if (fabs(climbVelocity) + fabs(climbMinVelocity) != 0.0)
            timeToTarget = 2 * fabs(climbTargetPosition - GetClimberPosition()) * 59.0 / (fabs(climbVelocity) + fabs(climbMinVelocity));
        else
            timeToTarget = 0.0;
        if (climbDecel != 0)
            timeToDecel = fabs(climbVelocity - climbMinVelocity * direction) / climbDecel; // Number of seconds needed to get to Min Velocity using decl
        else
            timeToDecl = 0.0;
        if (timeToDecel >= timeToTarget)
            {
            climbVelocityState = 1; // We need to decelerate now.  Best to go immediately to deceleration.  We need to start doing that now in order to reach minVelocity.
            fprintf(fpt,"Declerating\n");
            }
        else // No need to declerate yet.  Accelerate as needed till we reach the "maintain Velocity."
            {
            climbVelocity += climbAccel * diffTime * direction; // V2 = V1 + at
            if (fabs(climbVelocity) >= fabs(climbMaxVelocity))
                {
                climbVelocity = climbMaxVelocity * direction; // limit to MaxVelocity.
                }
            }
        }
    else
        { // Decelerating down to minVelocity
          // Now we need to decelerate in order to reach minVelocity as we reach the target position.
        climbVelocity -= climbDecel * diffTime * direction; // V2 = V1 + at
        if (direction > 0)
            { // If going positive, make sure we don't go below Min Velocity
            if (climbVelocity < climbMinVelocity)
                {
                climbVelocity = climbMinVelocity;
                }
            }
        else
            { // Going negative direction.  Make sure velocity does not go more positive than the negative min velocity
            if (climbVelocity > -climbMinVelocity)
                {
//                printf("climbVel=%f, climbMin=%f\n",climbVelocity,climbMinVelocity);
                climbVelocity = -climbMinVelocity;
                }
            }
        
        if (((GetClimberPosition() >= climbTargetPosition)&&(direction > 0)) || // If we've reached our target position, we're done the initial movement to grab the high bar.
                ((GetClimberPosition() <=climbTargetPosition)&&(direction < 0))) // make sure this is done correctly based on the direction we're going.
            {
            rval = 1; // Return True when movement profile is complete.
            climbVelocityState = 0;  // Set this to 0 in case someone forgets to do that before starting calls to adjustVelocity();
            }
        }
    fprintf(fpt,"vel=%f/%f, pos=%f, targ=%f accel=%f decl=%f min=%f max=%f diffTime=%f direction=%f, TTD=%f, TTT=%f\n",climbVelocity,GetClimberSpeed(),GetClimberPosition(),climbTargetPosition,climbAccel,climbDecel,climbMinVelocity,climbMaxVelocity,diffTime,direction,timeToDecel,timeToTarget);
    return(rval); // Returns True when target position has been reached.
    }

bool Climber::gentleDecel() // Do the deceleration part of Adjust Velocity to bring climb to a controlled stop
    {
    int rval; // Returns true when the target has been reached.
    double direction; // multiplier used to get the sign right.

    rval = false; // Assume we're not done yet
    thisTime = (double)frc::Timer::GetFPGATimestamp(); // Use FPGATime just in case some execution cycles are missed.
    diffTime = thisTime - lastTime; // will usually be 0.02 (1/50 sec) but it may sometimes be 0.04 or 0.06 if cycles are missed.
    if (diffTime > 0.10) // If we miss more than 5 time slices - or this is that start-up, set diffTime at 0.02
        { // First time through, diffTime will be quite a bit more thn 0.05 (normally)
        diffTime = 0.02; // Make sure we don't use some crazy high diffTime value.  That would cause problems.
        }
    lastTime = thisTime;

    // We don't care about position.  Just bring us to a stop by moving climbVelocity towards 0.

    if (climbVelocity > 0)
        { // Depending on direction, see if we're going slow enough to stop.
        climbVelocity -= climbDecel * diffTime;
        if (climbVelocity <= climbMinVelocity)
            {
            climberLeaderMotor.StopMotor(); // Make sure motor stops when we get to target.
            climbVelocityState = 0;
            rval = true;
            }
        }
    else
        { // Going negative direction.  Make sure velocity does not go more positive than the negative min velocity
        climbVelocity += climbDecel * diffTime;
        if (climbVelocity >= -climbMinVelocity)
            {
            climberLeaderMotor.StopMotor(); // Make sure motor stops when we get to target.
            climbVelocityState = 0;
            rval = true;
            }
        }  
//    fprintf(fpt,"GDCEL vel=%f/%f min=%f\n",climbVelocity,GetClimberSpeed(),climbMinVelocity);
    return(rval);
    }

void Climber::ClimbUp() // Called at 50Hz to have climbing system climb in the upward direction
    { 

    thisTime = (double)frc::Timer::GetFPGATimestamp(); // Use FPGATime just in case some execution cycles are missed.
    diffTime = thisTime - lastTime; // will usually be 0.02 (1/50 sec) but it may sometimes be 0.04 or 0.06 if cycles are missed.
    lastTime = thisTime;
    switch (climbState)
        {
        case CLIMBINGSETUP:
            // verify that we have air pressure.
            // If so, activate air cylinder to lift climber.  At the same time, we can being moving arm to position for grab of mid bar.
            // The air cylinder should be fast enough that the arm is up out of the robot in plenty of time.
            // No air pressure = no climb.
            break;
        case DRIVINGTOBAR: // This should be done by the driver to ensure a good, square line-up
            // A bar sensor could be helpful here but we can also rely on the operator for a button press to begin the climb process.

            // double straightUpPosition = -86.09;
            // double grabHighBarPosition = 56.5; //58.5
            // So, we want to move a displacement of 56.5 + 86.09 = 142.59 as our first climbing motion.  Let's target this to happen in 2 seconds for now.
            // Let's call the units for this displacement "ticks".  So we want to move 142.59 ticks in 2 seconds.  Average velocity will be 142.59/2 = 71.3 ticks/sec
            // and max velocity would end up at 142.59 (I think)
            // assuming we accelerate for 0.5 seconds, maintain for 1 second and decelerate for 0.5 seconds, 
            // to get to V2 of 71.3 in 0.5 seconds, accel would be V2 = v1 + at, 71.3 = 0 + a (0.5).  a = 142.59 ticks/s^2
            // Let's aim for a final velocity of 2 ticks per second (for now).  Decel will match Accel for now (142.59 ticks / s^2)
            // 
            // Set up the parameters for this first movement.  These values will all be positive except for climbTargetPosition (and originalPosition)
            // adjustSpeed() will take care of all calculations to correctly account for the direction the arm motor needs to go (based on orignalPosition and climbTargetPosition)
            // note that climbVelocity can be positive or negative.
            climbAccel = 142.59;
            climbDecel = 142.59;
            climbMaxVelocity = 71.3;
            climbMinVelocity = 2.0;
            climbTargetPosition = 56.5;
            originalPosition = GetClimberPosition();
            climbState = GRABHIGHBAR; // Move on the the state that will make the movement.
            break;
        case GRABHIGHBAR: // Perform the rotation motion to bring clamping claw up to the high bar
            // We'll want climbAccel, climbDecel, climbMaxVelocity, climbMinVelocity, climbTargetPosition, climbBarPresentTime
            // Use accel to bring velocity up to maxVel, then maintain maxVel till we need to decel such that we hit targPos at minVel
            // maintain minVel till bar is detected continuously for barTime, then clamp.
            // We should handle the condition where we may need to being decel before reaching maxVel in order to meet the minVel target at TargetPosition.
            if (adjustVelocity()) // keep calling adjustVelocity() till it returns true.
                {
                climbState = ENSUREHIGHBAR;
                }
            // time need to reach minVelocity by the time we get to target position is fairly simple if we're at MaxVel.  Otherwise, it's more complicated.
            break;        
        case ENSUREHIGHBAR: // Note that we still have climbMinVelocity active so climber arm will still be moving (unless climbMinVelocity is set at 0)
            // Now, we're going the other way to get the claw off of the mid bar.  There's no hard stop so we can really move as long as we stop in a controlled manner that minimizes swing
            // Note that swing introduction could be a bit different for this motion since the robot could be crossing the center of gravity of the high bar at a fair clip.
            // Mind you this is the point where we should be approaching a fairly low velocity as well so swing can be minimized.
            climbAccel = -142.59;
            climbDecel = -142.59;
            climbMaxVelocity = -71.3;
            climbMinVelocity = -2.0;
            climbTargetPosition = -9.5;
            climbSubState = 0; 
            break;
        case SWING1: // swing and Lift Off Mid Bar.
            if (adjustVelocity()) // keep calling adjustVelocity() till it returns true.
                {
                climbState = LIFTOFFMIDBAR;
                }
            break;       
        case LIFTOFFMIDBAR: // lifting off the bar
            break;        
        case MOVETOTRAVERSEBAR:
            break;
        case GRABTRAVERSEBAR:
            break;
        case ENSUREGRABTRAVERSEBAR:
            break;
        case SWING2: // second swing
            break;
        case LIFTOFFHIGHBAR:
            break;

    }

    }

void Climber::ClimbDown() // Called at 50Hz to have climbing system climb in the upward direction
    { 

    }



// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS


// Put methods for controlling this subsystem
// here. Call these from Commands.

