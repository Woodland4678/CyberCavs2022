// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "Subsystems/Climber.h"
#include <frc/Timer.h>
#include <frc/SmartDashboard/SmartDashboard.h>
#include "stdio.h"
#include "robot.h"

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS
//Climber positions for Practice Bot
// double horizontalPosition = 0.0;
// double straightUpPosition = 86.09;
// double grabHighBarPosition = -56.0; // -56.5; //58.5
// double liftOffMediumBarPosition = 10.0;
// double swingToTraverseBarPosition = -245; // -259
// double grabTraverseBarPosition = -226.5;
// double finalSwingPosition = -169.5;
// double liftOffHighBarPosition = -150.0;

// Climber Positions for Competition Bot.
double horizontalPosition = 5.5; // 12.0; // 3.5 not far up enough. 20.5 too far was 12.0 but something shifted
// after the arm removal accident.  Trying 5.0 
double straightUpPosition = -86.09;
double grabHighBarPosition = 66; //58.5
double liftOffMediumBarPosition = -5.0;
double swingToTraverseBarPosition = 248; // 245 For competition.  248 for sample climber
double grabTraverseBarPosition = 227.0;
double finalSwingPosition = 169.5;
double liftOffHighBarPosition = 130.0;

#define DEFAULT_ACCEL 3500
#define DEFAULT_DECEL 3500
#define DEFAULT_MAX_SPEED 3500
#define DEFAULT_MIN_SPEED 500
// CalibrateAngle is 0 on the practice bot.  A +35 value causes the robot to not go straight up  (stops early)
// A negative value would cause the arm to move further than expected (beyond straight up at start)
// On the flight bot, angle will normally be up slightly so starting angle should be slightly positive (about 5.0 to 7.0)

// #define DEFAULT_ACCEL 5000
// #define DEFAULT_DECEL 5000
// #define DEFAULT_MAX_SPEED 5000
// #define DEFAULT_MIN_SPEED 250


int climbState,climbSubState,climbVelocityState;
int inDeceleration,gotBarCount,noBarCount;
FILE *fpt;
double calibrateAngle;
int inPositionMode; // 0=velocity mode.  1=hold position mode.  PID values are quite different.

// Code to optimize the climb.
// Rather than position control, let's go with velocity control of the Spark Max / Neo Motor system.
// We're going to implement a forward/reverse climb that will allow the operator to climb in the upward direction and also downwards.
// It may be advantageous to also allow the operator to perform a climb reset which will assume the robot has been dislodges from the climb
// and needs to start from step 1 (or 2).  Most likely, the climber air cylinder will be in the up position.
// We'll want to disable climbing motor movement if the air pressure is not present.
// We can probably use the same states as the original climb sequence.
// void Climber::ClimbUp(){ will be called at 50Hz while a button is held to climb in the upward direction.
// void Climber::ClimbDown(){ will be called at 50Hz while a button is held to climb in the downward direction.
// When neither is pressed, we're expecting a call to a process that will bring the climber motor to a controlled stop
// Velocity will normally be changed quite gently in order to minimize the swing that may be experienced by sudden changes in velocity.
// We are going to use a few global values to manage motor speed
double thisTime,lastTime,diffTime;
double climbVelocity; // This is the target velocity of the climber (may be negative)
double timeToTarget, timeToDecel;
double originalPosition; // Used to make sure we're adjusting velocity in the correct direction.
double climbMinVelocity,climbMaxVelocity;
double timeToDecl;
double climbDecel,climbAccel;
double climbTargetPosition;

double climbP,climbI,climbD,climbFF;
double climb2P,climb2I,climb2D,climb2FF;

bool isClimbing = false;

rev::CANSparkMax climberLeaderMotor{7, rev::CANSparkMax::MotorType::kBrushless};
rev::CANSparkMax climberFollowerMotor{9, rev::CANSparkMax::MotorType::kBrushless};
rev::SparkMaxPIDController climberPidController = climberLeaderMotor.GetPIDController();
rev::SparkMaxRelativeEncoder climberEncoder = climberLeaderMotor.GetEncoder();


Climber::Climber() : frc::Subsystem("Climber") {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    AddChild("heightSolenoid", heightSolenoid);


    AddChild("reachSolenoid", reachSolenoid);


    AddChild("LockSolenoid", lockSolenoid);

    calibrateLimit.reset(new frc::DigitalInput(5));
    barSensor.reset(new frc::DigitalInput(6));

    AddChild("calibrateLimit", calibrateLimit);

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    climberFollowerMotor.Follow(climberLeaderMotor);

    climbP = 0.00025; // 0.0001
    climbI = 0.000001;
    climbD = 0.0;
    climbFF = 0.0; // 0.000175
    climberPidController.SetP(0.0001); // 0.00025
    climberPidController.SetI(0.000001); // 0.000001
    climberPidController.SetD(0);
    climberPidController.SetFF(0.000175);
    climberPidController.SetOutputRange(-1.0, 1.0);

    frc::SmartDashboard::PutNumber("Climb P", climbP);
    frc::SmartDashboard::PutNumber("Climb I", climbI);
    frc::SmartDashboard::PutNumber("Climb D", climbD);
    frc::SmartDashboard::PutNumber("Climb FF", climbFF);

//    climberPidController.SetP(0.075);
//    climberPidController.SetI(0);
//    climberPidController.SetD(0);
//    climberPidController.SetOutputRange(-0.85, 0.85);
    calibrateAngle = GetClimberPosition(); // Ensuring calibrate won't move more than +/- 7 degrees or so.
}

void Climber::InitDefaultCommand() {
    // Set the default command for a subsystem here.
    // SetDefaultCommand(new MySpecialCommand());
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
}

void Climber::Periodic() {
    // Put code here to be run every loop
    frc::SmartDashboard::PutNumber("Climber Position", climberEncoder.GetPosition());
    frc::SmartDashboard::PutBoolean("Climber calibration switch", calibrateLimit->Get());
}
void Climber::SetClimberPower(double pwr) {
    //climberPidController.SetReference(pwr, rev::ControlType::kVelocity);
    climberLeaderMotor.Set(pwr);
}
void Climber::SetClimberMode(bool climberMode) {
    climbState = 0;
    isClimbing = climberMode;
}
bool Climber::GetClimberMode() {
    return isClimbing;
}
bool Climber::MoveClimberLevel() {
    inPositionMode = 0;
    SetClimberPosition(horizontalPosition);
    if (abs(climberEncoder.GetPosition() - horizontalPosition) < 0.5) {
        return true;
    }
    return false;
}
void Climber::SetClimberVelocity(double vel) {
    if (inPositionMode)
        { // If we were in position mode, change PID values to those that work for velocity control.
        climberPidController.SetP(0.0001); // 0.00025
        climberPidController.SetI(0.000001); // 0.000001
        climberPidController.SetD(0);
        climberPidController.SetFF(0.000175);
        climberPidController.SetOutputRange(-1.0, 1.0);
        inPositionMode = 0;
        }
    climberPidController.SetReference(vel, rev::ControlType::kVelocity);
}


void Climber::SetClimberPosition(double position){
    if (!inPositionMode) // If we were in velocity mode, change PID values that work for position control.
        {
        climberPidController.SetP(0.075);
        climberPidController.SetI(0);
        climberPidController.SetD(0);
        climberPidController.SetOutputRange(-0.85, 0.85);
        climberPidController.SetFF(0.0);
        inPositionMode = 1; // Indicate that we are now in position mode.
        }
    climberPidController.SetReference(position, rev::ControlType::kPosition);
}

void Climber::IncreaseClimbState() {
    climbState++;
}

bool isClicked = true;
int pressureHighCnt = 0;

// Modifying CalibrateClimber so that it will only move the arm about 5 degrees, then gives up and assumes a default angle.
// 
bool Climber::CalibrateClimber(){
    climbState = 0;
    originalPosition = GetClimberPosition();
    if (Robot::driveTrain->getTankPressure()>=45) {
        pressureHighCnt++;
    }
    
    if (pressureHighCnt >= 10){
        RaiseClimber();
        if (fabs(GetClimberPosition() - calibrateAngle) > 15.0)
            { // If we exceded the 7 degree limit, assume horizontal was our starting position 
            climberLeaderMotor.StopMotor(); // Stop moving
            if (fpt != NULL)
                fprintf(fpt,"Cal Exceeded Pos=%f, Cal Angle = %f, Set To=%f\n",GetClimberPosition(),calibrateAngle,horizontalPosition + (GetClimberPosition() - calibrateAngle));
            climberEncoder.SetPosition(horizontalPosition + (GetClimberPosition() - calibrateAngle)); // Set position as if it was correct to start with.
            printf("CLIMBER Set Position to %f, %f,%f,%f\n\r",(GetClimberPosition() - calibrateAngle),horizontalPosition,GetClimberPosition(),calibrateAngle);
            return true;
            }
        if (!calibrateLimit->Get() &&isClicked){
            SetClimberVelocity(-500);
        }

        else if(calibrateLimit->Get()){
            SetClimberVelocity(500);
            isClicked=false;
        }else{
            printf("Climber Set Position to %f\n\r",horizontalPosition);
            climberEncoder.SetPosition(horizontalPosition);
            isClicked = true;
            climberLeaderMotor.StopMotor();

            return true;
        }
    }

    return false;
}

double Climber::GetClimberPosition(){ 
    return(climberEncoder.GetPosition());
}

double Climber::GetClimberSpeed(){ 
    return(climberEncoder.GetVelocity());
}

void Climber::ExtendReachingArm(){
    reachSolenoid.Set(frc::DoubleSolenoid::Value::kReverse); // Red Wire
}

void Climber::RetractReachingArm(){
     reachSolenoid.Set(frc::DoubleSolenoid::Value::kForward); // Green Wire
}

void Climber::Lock(){
     lockSolenoid.Set(frc::DoubleSolenoid::Value::kReverse); // Black Wire
}

void Climber::Unlock(){
     lockSolenoid.Set(frc::DoubleSolenoid::Value::kForward); // White Wire
}

void Climber::RaiseClimber(){
     heightSolenoid.Set(frc::DoubleSolenoid::Value::kReverse);
}

void Climber::LowerClimber(){
     heightSolenoid.Set(frc::DoubleSolenoid::Value::kForward);
}

/*
enum {
    CLIMBINGSETUP,
    DRIVINGTOBAR,
    GRABHIGHBAR,
    ENSUREHIGHBAR,
    SWING1,
    LIFTOFFMIDBAR,
    MOVETOTRAVERSEBAR,
    GRABTRAVERSEBAR,
    ENSUREGRABTRAVERSEBAR,
    SWING2,
    LIFTOFFHIGHBAR
};
*/

void Climber::OpenFile()
    {
    fpt = fopen("/media/sda1/test.txt","w"); // Open file for logging.
    }

void Climber::CloseFile()
    {
    if (fpt != NULL)
        {
        fputs("The End\n",fpt);
        fclose(fpt);
        fpt = NULL; // Make sure there's no further attempts to write to the file (would cause a crash)
        }
    climbState = 0;
    }

int climbCount = 0;
int prevpov = -1;
void Climber::Climb(){

// When climb is activated, do the homing thing.  This should probably happen when robot is first activated in auto.    
// Checking POV here to determine what to do.  -1 if no buttons are pressed (controlled stop)
// 0 if Up, 180 if Down
// 270 Left (exit)
// 90 Can be used for immediate stop.

//    climbCount++;
// fprintf(fpt,"climbing state = %d, POV=%d\n",climbState,Robot::oi->getDriverGamepad()->GetPOV());
    int pov;
    if (Robot::oi->getOperatorGamepad()->GetRawButton(4)) {
        pov = 0;
    }
    else if (Robot::oi->getOperatorGamepad()->GetRawButton(2)) {
        pov = 180;
    }
    else if (Robot::oi->getOperatorGamepad()->GetRawButton(3)) {
        pov = 270;
    }
    else
        pov = -1; // No buttons pressed.
    //pov = Robot::oi->getDriverGamepad()->GetPOV();
    if (prevpov != pov)
        {
        // This code can be used for tuning the PID for velocity climb.
        // climb2P = frc::SmartDashboard::GetNumber("Climb P",0.00025);
        // climb2I = frc::SmartDashboard::GetNumber("Climb I",0.000001);
        // climb2D = frc::SmartDashboard::GetNumber("Climb D",0.0);
        // climb2FF = frc::SmartDashboard::GetNumber("Climb FF",0.0);
        // if (climbP != climb2P)
        //     {
        //     climberPidController.SetP(climb2P);
        //     climbP = climb2P;
        //     }
        // if (climbI != climb2I)
        //     {
        //     climberPidController.SetI(climb2I);
        //     climbI = climb2I;
        //     }
        // if (climbD != climb2D)
        //     {
        //     climberPidController.SetD(climb2D);    
        //     climbD = climb2D;
        //     }
        // if (climbFF != climb2FF)
        //     {
        //     climberPidController.SetFF(climb2FF);
        //     climbFF = climb2FF;
        //     }
        if (fpt != NULL)
            fprintf(fpt,"POV Change %d to %d\n",prevpov,pov);
        }
    switch(climbState)
        {
        case 0: // Go to vertical position
            climbAccel = DEFAULT_ACCEL; // 10000
            climbDecel = DEFAULT_DECEL; // 10000
            climbMaxVelocity = DEFAULT_MAX_SPEED; // 6000
            climbMinVelocity = DEFAULT_MIN_SPEED;
            climbTargetPosition = straightUpPosition;
            ExtendReachingArm();
            Unlock();
            if (!adjustVelocity()) // Make speed adjustments according to the global parameters
                {
                SetClimberVelocity(climbVelocity);
                }
            else
                {
                originalPosition = GetClimberPosition(); // Assign originalPosition to current position when nothing pressed.
                climberLeaderMotor.StopMotor(); // Make sure motor stops when we get to target.
                climbSubState = VERTICALTOFROMMIDBAR; // We're at position, move on.
                climbState = 1;
                }
            climberLeaderMotor.SetIdleMode(rev::CANSparkMax::IdleMode::kBrake); //make sure we are in brake mode
            climberFollowerMotor.SetIdleMode(rev::CANSparkMax::IdleMode::kBrake);
            break;
        case 1: // We have calibrate point.  Read to climb up (or down)
            if (pov == 0) // Up button held
                {
                switch(climbSubState)
                    {
                    case HORIZONTALTOFROMVERTICAL: // In this state, up will move to the climb start position
                        climbSubState = VERTICALTOFROMMIDBAR;
                        break;
                        // climbAccel = 10000; // DEFAULT_ACCEL; // 10000
                        // climbDecel = 10000; // DEFAULT_DECEL; // 10000
                        // climbMaxVelocity = 6000; // DEFAULT_MAX_SPEED; // 6000
                        // climbMinVelocity = DEFAULT_MIN_SPEED;
                        // climbTargetPosition = straightUpPosition;
                        // ExtendReachingArm();
                        // if (!adjustVelocity()) // Make speed adjustments according to the global parameters
                        //     {
                        //     SetClimberVelocity(climbVelocity);
                        //     }
                        // else
                        //     {
                        //     originalPosition = GetClimberPosition(); // Assign originalPosition to current position when nothing pressed.
                        //     climberLeaderMotor.StopMotor(); // Make sure motor stops when we get to target.
                        //     climbSubState = VERTICALTOFROMMIDBAR; // We're at position, move on.
                        //     }
                        // break;
                    case VERTICALTOFROMMIDBAR: // Do the initial lift to near or at the position for lock.
                        climbAccel = 6000; // DEFAULT_ACCEL; // 6000
                        climbDecel = 6000; // DEFAULT_DECEL; // 6000
                        climbMaxVelocity = 5000; // DEFAULT_MAX_SPEED; // 5000
                        climbMinVelocity = 1000; // DEFAULT_MIN_SPEED; // 1000
                        climbTargetPosition = grabHighBarPosition;
                        if (barSensor->Get() == 0)
                            {
                            gotBarCount++;
                            }
                        else
                            {
                            gotBarCount = 0;
                            noBarCount++;
                            }
                        if (!adjustVelocity()) // &&(gotBarCount < 10)) // Make speed adjustments according to the global parameters
                            { 
                            SetClimberVelocity(climbVelocity);
                            if (gotBarCount >= 10) // If we get a bar count large enough that we should lock, go do the lock.
                                {
                                originalPosition = GetClimberPosition(); // Assign originalPosition to current position when nothing pressed.
                                climberLeaderMotor.StopMotor(); // Make sure motor stops when we get to target.
                                climbVelocity = 0; // Velocity is essentially 0 here.
                                climbSubState = MIDBARTOFROMLOCKPOS; // We're at position, move on.
                                }
                            noBarCount = 0; // leave this at 0 till we get to the target.  Then we can use it as a time-out to lock even if we're not getting the bar signal.
                            }
                        else // If motion ends, clamp regardless.  If we stay in this state, robot will continue motion and wreck itself
                            {                            
                            // if ((gotBarCount > 6)||(noBarCount > 30))
                            //     {
                            originalPosition = GetClimberPosition(); // Assign originalPosition to current position when nothing pressed.
                            climberLeaderMotor.StopMotor(); // Make sure motor stops when we get to target.
                            climbVelocity = 0; // Velocity is essentially 0 here.
                            climbSubState = MIDBARTOFROMLOCKPOS; // We're at position, move on.
                            //     }
                            }
                        break;
                    case MIDBARTOFROMLOCKPOS:
                        // Gentle move in to the position for locking - check sensor (if it's connected) and do the lock.
                        Lock();
                        climbVelocityState = 0;  // Set this to 0 to make sure we do accel, not just decl.
                        climbSubState = LOCKPOSTOFROMRETRACT;
                        break;
                    case LOCKPOSTOFROMRETRACT:  // Lift claw from bar to point where we can retract.
                        climbAccel = 6000; // DEFAULT_ACCEL; // 6000
                        climbDecel = 6000; // DEFAULT_DECEL; // 6000
                        climbMaxVelocity = 4000; //DEFAULT_MAX_SPEED; // 4000
                        climbMinVelocity = DEFAULT_MIN_SPEED;
                        climbTargetPosition = liftOffMediumBarPosition;
                        if (!adjustVelocity()) // Make speed adjustments according to the global parameters
                            {
                            SetClimberVelocity(climbVelocity);
                            }
                        else
                            {
                            originalPosition = GetClimberPosition(); // Assign originalPosition to current position when nothing pressed.
                            climberLeaderMotor.StopMotor(); // Make sure motor stops when we get to target.
                            climbSubState = RETRACTCLAW; // We're at position, move on.
                            }
                        break;
                    case RETRACTCLAW: // Retract Claw
                        RetractReachingArm();
                        climbSubState = RETRACTTOFROMEXTEND;
                        break;
                    case RETRACTTOFROMEXTEND: // Long Swing all the way to bring claw above traverse bar. -243.5
                        climbAccel = 6000; // DEFAULT_ACCEL; // 6000
                        climbDecel =  4000; //DEFAULT_DECEL; // 4000
                        climbMaxVelocity =  5000; //DEFAULT_MAX_SPEED; // 5000
                        climbMinVelocity = DEFAULT_MIN_SPEED;
                        climbTargetPosition = swingToTraverseBarPosition;
                        if (!adjustVelocity()) // Make speed adjustments according to the global parameters
                            {
                            SetClimberVelocity(climbVelocity);
                            }
                        else
                            {
                            originalPosition = GetClimberPosition(); // Assign originalPosition to current position when nothing pressed.
                            climberLeaderMotor.StopMotor(); // Make sure motor stops when we get to target.
                            climbSubState = EXTENDCLAW; // We're at position, move on.
                            }
                        break;
                    case EXTENDCLAW: // should now be able to extend the claw and unlock
                        ExtendReachingArm();
                        Unlock();
                        climbSubState = EXTENDTOFROMTRAVERSE;
                        break;
                    case EXTENDTOFROMTRAVERSE: // Lower on to Traverse Bar -226.5
                        climbAccel = 6000; // DEFAULT_ACCEL; // 6000
                        climbDecel = 6000; // DEFAULT_DECEL; // 6000
                        climbMaxVelocity = 5000; // DEFAULT_MAX_SPEED; // 5000
                        climbMinVelocity = DEFAULT_MIN_SPEED;
                        climbTargetPosition = grabTraverseBarPosition;
                        if (!adjustVelocity()) // Make speed adjustments according to the global parameters
                            {
                            SetClimberVelocity(climbVelocity);
                            }
                        else
                            {
                            originalPosition = GetClimberPosition(); // Assign originalPosition to current position when nothing pressed.
                            climberLeaderMotor.StopMotor(); // Make sure motor stops when we get to target.
                            climbSubState = TRAVERSETOFROMFINAL; // We're at position, move on.
                            }
                        break;
                    case TRAVERSETOFROMFINAL: // Lift off high bar -139.5
                        climbAccel = 3000; // DEFAULT_ACCEL; // 3000
                        climbDecel = 3000; // DEFAULT_DECEL; // 3000
                        climbMaxVelocity = 3500; // DEFAULT_MAX_SPEED; // 3500
                        climbMinVelocity = DEFAULT_MIN_SPEED;
                        climbTargetPosition = liftOffHighBarPosition;
                        if (!adjustVelocity()) // Make speed adjustments according to the global parameters
                            {
                            SetClimberVelocity(climbVelocity);
                            }
                        else
                            {
                            originalPosition = GetClimberPosition(); // Assign originalPosition to current position when nothing pressed.
                            // climberLeaderMotor.StopMotor(); // Make sure motor stops when we get to target.
                            SetClimberPosition(liftOffHighBarPosition); // Do a position command to hold this position.
                            climbSubState = ENDOFCLIMB; // We're at position, move on.
                            }
                        break;
                    case ENDOFCLIMB: // Climb is done.  Reverse is still allowed though.
                        // At this point, we want to have the climber hold position till disable at the end of the match.
                        // Change to position control and set position to liftOffHighBarPosition

                        break;
                    }   

                }
            else if (pov == 180)
                { // Down held
                switch(climbSubState)
                    {
                    case HORIZONTALTOFROMVERTICAL: // In this state, up will move to the climb start position - probably not a good idea if the bar is still right there.
                        // if (GetClimberPosition() < 0) // If we're not at horizontal yet, move there.
                        //     {
                        //     climbAccel = 6000;
                        //     climbDecel = 6000;
                        //     climbMaxVelocity = 6000;
                        //     climbMinVelocity = 500;
                        //     climbTargetPosition = horizontalPosition;
                        //     ExtendReachingArm(); // 
                        //     if (!adjustVelocity()) // Make speed adjustments according to the global parameters
                        //         {
                        //         SetClimberVelocity(climbVelocity);
                        //         }
                        //     else
                        //         {
                        //         originalPosition = GetClimberPosition(); // Assign originalPosition to current position when nothing pressed.
                        //         climberLeaderMotor.StopMotor(); // Make sure motor stops when we get to target.
                        //         climbSubState = VERTICALTOFROMMIDBAR; // We're at position, move on.
                        //         }
                        //     }
                        // else
                        //     {
                        //     climberLeaderMotor.StopMotor(); // If we've gone to (or just past) horizontal.  Do a stop at this location.
                        //     originalPosition = GetClimberPosition(); // Assign originalPosition to current position when nothing pressed.
                        //     }
                        break;
                    case VERTICALTOFROMMIDBAR: // going back down from lock position to vertical - basically setting the robot back down on the ground.
                        climbAccel = DEFAULT_ACCEL;
                        climbDecel = DEFAULT_DECEL;
                        climbMaxVelocity = DEFAULT_MAX_SPEED;
                        climbMinVelocity = DEFAULT_MIN_SPEED; // 500
                        climbTargetPosition = straightUpPosition;
                        if (!adjustVelocity()) // Make speed adjustments according to the global parameters
                            {
                            SetClimberVelocity(climbVelocity);
                            }
                        else
                            {
                            originalPosition = GetClimberPosition(); // Assign originalPosition to current position when nothing pressed.
                            climberLeaderMotor.StopMotor(); // Make sure motor stops when we get to target.
                            climbSubState = HORIZONTALTOFROMVERTICAL; // We're at position, move on.
                            }
                        break;
                    case MIDBARTOFROMLOCKPOS: // Up would have locked at this point we need to unlock to undo that.
                        // May need to move a bit to ensure we're in good contact with the bar for release of the lock.
                        Unlock();
                        climbSubState = VERTICALTOFROMMIDBAR; // move down a state to begin lowering robot to the ground.
                        break;
                    case LOCKPOSTOFROMRETRACT: // This would be moving from where the claw was retracted back on to the mid bar so we can release the lock.
                        climbAccel = DEFAULT_ACCEL;
                        climbDecel = DEFAULT_DECEL;
                        climbMaxVelocity = DEFAULT_MAX_SPEED;
                        climbMinVelocity = DEFAULT_MIN_SPEED; // 500;
                        climbTargetPosition = grabHighBarPosition;
                        if (!adjustVelocity()) // Make speed adjustments according to the global parameters
                            {
                            SetClimberVelocity(climbVelocity);
                            }
                        else
                            {
                            originalPosition = GetClimberPosition(); // Assign originalPosition to current position when nothing pressed.
                            climberLeaderMotor.StopMotor(); // Make sure motor stops when we get to target.
                            climbSubState = MIDBARTOFROMLOCKPOS; // We're at position, move on.
                            }
                        break;
                    case RETRACTCLAW: // claw will be just above mid bar.  Time to extend it now actually.
                        ExtendReachingArm();
                        climbSubState = LOCKPOSTOFROMRETRACT;
                        break;
                    case RETRACTTOFROMEXTEND: // This is the big long swing from above the traverse bar to above the mid bar.
                        climbAccel = DEFAULT_ACCEL;
                        climbDecel = DEFAULT_DECEL;
                        climbMaxVelocity = DEFAULT_MAX_SPEED;
                        climbMinVelocity = DEFAULT_MIN_SPEED; // 500;
                        climbTargetPosition = liftOffMediumBarPosition;
                        if (!adjustVelocity()) // Make speed adjustments according to the global parameters
                            {
                            SetClimberVelocity(climbVelocity);
                            }
                        else
                            {
                            originalPosition = GetClimberPosition(); // Assign originalPosition to current position when nothing pressed.
                            climberLeaderMotor.StopMotor(); // Make sure motor stops when we get to target.
                            climbSubState = RETRACTCLAW; // We're at position, move on.
                            }
                        break;
                    case EXTENDCLAW: // This will actually now be a retract claw.
                        RetractReachingArm();
                        Lock(); // Also good time to re-lock the locking arm part since we should be sitting on the high bar with it.
                        climbSubState = RETRACTTOFROMEXTEND;
                        break;
                    case EXTENDTOFROMTRAVERSE: // do motion to lift claw off of the traverse bar.
                        climbAccel = DEFAULT_ACCEL;
                        climbDecel = DEFAULT_DECEL; // 3500
                        climbMaxVelocity = DEFAULT_MAX_SPEED;
                        climbMinVelocity = DEFAULT_MIN_SPEED; // 500;
                        climbTargetPosition = swingToTraverseBarPosition; //  - 5.0;
                        if (!adjustVelocity()) // Make speed adjustments according to the global parameters
                            {
                            SetClimberVelocity(climbVelocity);
                            }
                        else
                            {
                            originalPosition = GetClimberPosition(); // Assign originalPosition to current position when nothing pressed.
                            climberLeaderMotor.StopMotor(); // Make sure motor stops when we get to target.
                            climbSubState = EXTENDCLAW; // We're at position, move on.
                            }
                        break;
                    case TRAVERSETOFROMFINAL: // do motion to bring locking arm back down on to high bar
                        ExtendReachingArm();
                        Unlock();
                        climbSubState = EXTENDTOFROMTRAVERSE;
                        break;
                    case ENDOFCLIMB: // From End of climb, lower locking claw back down on to the high bar
                        climbAccel = DEFAULT_ACCEL;
                        climbDecel = DEFAULT_DECEL;
                        climbMaxVelocity = DEFAULT_MAX_SPEED;
                        climbMinVelocity = DEFAULT_MIN_SPEED; // 500;
                        climbTargetPosition = grabTraverseBarPosition;
                        if (!adjustVelocity()) // Make speed adjustments according to the global parameters
                            {
                            SetClimberVelocity(climbVelocity); // System might be in position mode but this will change back to speed control.  May need PID updates if position is much different than velocity.
                            }
                        else
                            {
                            originalPosition = GetClimberPosition(); // Assign originalPosition to current position when nothing pressed.
                            climberLeaderMotor.StopMotor(); // Make sure motor stops when we get to target.
                            climbSubState = TRAVERSETOFROMFINAL; // We're at position, move on.
                            }
                        break;
                    }
                }
            else if (pov == 270)
                { // This is a sudden stop and reset
                climberLeaderMotor.StopMotor();
                climbState = 2; // Go to State 2
                climbSubState = 0; // Reset this to 0 just in case.  Basically allow climb to resume from the very beginning.
                }
            else // Neither up, nor down, do controlled deceleration (as long as we're not in position mode)
                { // pressing up or down will simply resume where we left off.
                if (!inPositionMode) // Only consider gentleDecel when we're in velocity mode, not when in position mode.
                    {
                    if (prevpov != pov) // If just released, indicate we are in a gentle decel state.
                        {
                        inDeceleration = 1; // Indicate we are in a deceleration event
                        climbDecel = 10000; // Do a fairly fast decelerate.  We typically want to stop fairly quickly.
                        }
                    if (gentleDecel())
                        {
                        originalPosition = GetClimberPosition(); // Assign originalPosition to current position when nothing pressed.
                        inDeceleration = 0; // No longer in a deceleration event
        //                climbSubState = 0;
        //                climbState = 2; // Controlled stop is complete.  Go to state 2.
                        }
                    else
                        {
                        if (inDeceleration)
                            SetClimberVelocity(climbVelocity);
                        else
                            climberLeaderMotor.StopMotor(); // Make sure motor stops.
                        }
                    }
                }
            break;
        case 2: // The stop and reset button was pressed.  This would be used if our climb was drastically interrupted (knocked off the bar)
            // This will reset the climber by going back to state 0 where the arm will move quickly to the straight-up start position.
            // If this was to take place when the robot was on the traverse bar, that would be a big problem since going to the start position
            // will swing the arm down through the robot (with the bar in place) and may damage things.
            // In order to get back to state 0, let's require the operator to press a rather obscure button here before going back to state 0.
            if (Robot::oi->getOperatorGamepad()->GetRawButton(9)) // "Back" Button pressed
                {
                climbState = 0; // Back to state that will send arm up, ready to grab the bar
                // climbSubState = 0; // climbSubState will be set in climbState 0 so no need to set that here.
                }
            break;
        }
    prevpov = pov;
    }

bool Climber::adjustVelocity() // Make speed adjustments according to the global parameters
    {
    int rval; // Returns true when the target has been reached.
    double direction; // multiplier used to get the sign right.

    rval = 0; // return False by default.
    thisTime = (double)frc::Timer::GetFPGATimestamp(); // Use FPGATime just in case some execution cycles are missed.
    diffTime = thisTime - lastTime; // will usually be 0.02 (1/50 sec) but it may sometimes be 0.04 or 0.06 if cycles are missed.
    if (diffTime > 0.10) // If we miss more than 5 time slices - or this is that start-up, set diffTime at 0.02
        { // First time through, diffTime will be quite a bit more thn 0.05 (normally)
        diffTime = 0.02; // Make sure we don't use some crazy high diffTime value.  That would cause problems.
        }
    lastTime = thisTime;
    if (climbTargetPosition > originalPosition)
        direction = 1;
    else if (climbTargetPosition < originalPosition)
        direction = -1;
    else
        direction = 0; // Target matches Original.  There's actually no reason to move at all.
    if (climbVelocityState == 0) // If we're still in the accelerate / maintain max velocity mode, do that.
        {
        // Accelerating / maintain max velocity.
        // Do a quick check to see if we need to skip Maintain Max Velocity and go directly to decelerate.
        // V2 = V1 + at, t = (V2 - V1) / a
        // Also need to calculate how long we need to reach our TargetPosition.  d = 1/2(V1 + V2)t, t = 2d/(V1 + V2)
        // easiest formula for that is t = 2d / (V1 + V2)
        // Check distance left to go given current velocity and final velocity
        // Velocity is in RPM.  Position is NOT rotations.  It's 42 counts per revolution, then we have the gearing.
        // We really don't need to worry about this velocity profile ever changing direction.  We'll come to a stop in the states before making a direction change.
        // 
        if (fabs(climbVelocity) + fabs(climbMinVelocity) != 0.0) // Was *59 with P=0.00025, I=0.000001.  67 works with P=0.0001, I=0.000001, FF= 0.000175
            timeToTarget = 2 * fabs(climbTargetPosition - GetClimberPosition()) * 67.0 / (fabs(climbVelocity) + fabs(climbMinVelocity));
        else
            timeToTarget = 0.0;
        if (climbDecel != 0)
            timeToDecel = fabs(climbVelocity - climbMinVelocity * direction) / climbDecel; // Number of seconds needed to get to Min Velocity using decl
        else
            timeToDecl = 0.0;
        if (timeToDecel >= timeToTarget)
            {
            climbVelocityState = 1; // We need to decelerate now.  Best to go immediately to deceleration.  We need to start doing that now in order to reach minVelocity.
            if (fpt != NULL)
                fprintf(fpt,"Declerating\n");
            }
        else // No need to declerate yet.  Accelerate as needed till we reach the "maintain Velocity."
            {
            climbVelocity += climbAccel * diffTime * direction; // V2 = V1 + at
            if (fabs(climbVelocity) >= fabs(climbMaxVelocity))
                {
                climbVelocity = climbMaxVelocity * direction; // limit to MaxVelocity.
                }
            }
        }
    else
        { // Decelerating down to minVelocity
          // Now we need to decelerate in order to reach minVelocity as we reach the target position.
        climbVelocity -= climbDecel * diffTime * direction; // V2 = V1 + at
        if (direction > 0)
            { // If going positive, make sure we don't go below Min Velocity
            if (climbVelocity < climbMinVelocity)
                {
                climbVelocity = climbMinVelocity;
                }
            }
        else
            { // Going negative direction.  Make sure velocity does not go more positive than the negative min velocity
            if (climbVelocity > -climbMinVelocity)
                {
//                printf("climbVel=%f, climbMin=%f\n",climbVelocity,climbMinVelocity);
                climbVelocity = -climbMinVelocity;
                }
            }
        
        if (((GetClimberPosition() >= climbTargetPosition)&&(direction > 0)) || // If we've reached our target position, we're done the initial movement to grab the high bar.
                ((GetClimberPosition() <=climbTargetPosition)&&(direction < 0))) // make sure this is done correctly based on the direction we're going.
            {
            rval = 1; // Return True when movement profile is complete.
            climbVelocityState = 0;  // Set this to 0 in case someone forgets to do that before starting calls to adjustVelocity();
            }
        }
    if (fpt != NULL)
        fprintf(fpt,"vel=%f/%f, pos=%f, targ=%f accel=%f decl=%f min=%f max=%f diffTime=%f direction=%f, TTD=%f, TTT=%f bs=%d\n",climbVelocity,GetClimberSpeed(),GetClimberPosition(),climbTargetPosition,climbAccel,climbDecel,climbMinVelocity,climbMaxVelocity,diffTime,direction,timeToDecel,timeToTarget,barSensor->Get());
    return(rval); // Returns True when target position has been reached.
    }

bool Climber::gentleDecel() // Do the deceleration part of Adjust Velocity to bring climb to a controlled stop
    {
    int rval; // Returns true when the target has been reached.
    double direction; // multiplier used to get the sign right.

    rval = false; // Assume we're not done yet
    thisTime = (double)frc::Timer::GetFPGATimestamp(); // Use FPGATime just in case some execution cycles are missed.
    diffTime = thisTime - lastTime; // will usually be 0.02 (1/50 sec) but it may sometimes be 0.04 or 0.06 if cycles are missed.
    if (diffTime > 0.10) // If we miss more than 5 time slices - or this is that start-up, set diffTime at 0.02
        { // First time through, diffTime will be quite a bit more thn 0.05 (normally)
        diffTime = 0.02; // Make sure we don't use some crazy high diffTime value.  That would cause problems.
        }
    lastTime = thisTime;

    // We don't care about position.  Just bring us to a stop by moving climbVelocity towards 0.

    if (climbVelocity > 0)
        { // Depending on direction, see if we're going slow enough to stop.
        climbVelocity -= climbDecel * diffTime;
        if (climbVelocity <= climbMinVelocity)
            {
            climberLeaderMotor.StopMotor(); // Make sure motor stops when we get to target.
            climbVelocityState = 0;
            rval = true;
            }
        }
    else
        { // Going negative direction.  Make sure velocity does not go more positive than the negative min velocity
        climbVelocity += climbDecel * diffTime;
        if (climbVelocity >= -climbMinVelocity)
            {
            climberLeaderMotor.StopMotor(); // Make sure motor stops when we get to target.
            climbVelocityState = 0;
            rval = true;
            }
        }  
    if ((!rval)&&(fpt != NULL))
        fprintf(fpt,"GD: vel=%f/%f, pos=%f, targ=%f accel=%f decl=%f min=%f max=%f diffTime=%f direction=%f, TTD=%f, TTT=%f bs=%d\n",climbVelocity,GetClimberSpeed(),GetClimberPosition(),climbTargetPosition,climbAccel,climbDecel,climbMinVelocity,climbMaxVelocity,diffTime,direction,timeToDecel,timeToTarget,barSensor->Get());

//    fprintf(fpt,"GDCEL vel=%f/%f min=%f\n",climbVelocity,GetClimberSpeed(),climbMinVelocity);
    return(rval);
    }

void Climber::ClimbUp() // Called at 50Hz to have climbing system climb in the upward direction
    { 

    thisTime = (double)frc::Timer::GetFPGATimestamp(); // Use FPGATime just in case some execution cycles are missed.
    diffTime = thisTime - lastTime; // will usually be 0.02 (1/50 sec) but it may sometimes be 0.04 or 0.06 if cycles are missed.
    lastTime = thisTime;
    switch (climbState)
        {
        case CLIMBINGSETUP:
            // verify that we have air pressure.
            // If so, activate air cylinder to lift climber.  At the same time, we can being moving arm to position for grab of mid bar.
            // The air cylinder should be fast enough that the arm is up out of the robot in plenty of time.
            // No air pressure = no climb.
            break;
        case DRIVINGTOBAR: // This should be done by the driver to ensure a good, square line-up
            // A bar sensor could be helpful here but we can also rely on the operator for a button press to begin the climb process.

            // double straightUpPosition = -86.09;
            // double grabHighBarPosition = 56.5; //58.5
            // So, we want to move a displacement of 56.5 + 86.09 = 142.59 as our first climbing motion.  Let's target this to happen in 2 seconds for now.
            // Let's call the units for this displacement "ticks".  So we want to move 142.59 ticks in 2 seconds.  Average velocity will be 142.59/2 = 71.3 ticks/sec
            // and max velocity would end up at 142.59 (I think)
            // assuming we accelerate for 0.5 seconds, maintain for 1 second and decelerate for 0.5 seconds, 
            // to get to V2 of 71.3 in 0.5 seconds, accel would be V2 = v1 + at, 71.3 = 0 + a (0.5).  a = 142.59 ticks/s^2
            // Let's aim for a final velocity of 2 ticks per second (for now).  Decel will match Accel for now (142.59 ticks / s^2)
            // 
            // Set up the parameters for this first movement.  These values will all be positive except for climbTargetPosition (and originalPosition)
            // adjustSpeed() will take care of all calculations to correctly account for the direction the arm motor needs to go (based on orignalPosition and climbTargetPosition)
            // note that climbVelocity can be positive or negative.
            climbAccel = 142.59;
            climbDecel = 142.59;
            climbMaxVelocity = 71.3;
            climbMinVelocity = 2.0;
            climbTargetPosition = 56.5;
            originalPosition = GetClimberPosition();
            climbState = GRABHIGHBAR; // Move on the the state that will make the movement.
            break;
        case GRABHIGHBAR: // Perform the rotation motion to bring clamping claw up to the high bar
            // We'll want climbAccel, climbDecel, climbMaxVelocity, climbMinVelocity, climbTargetPosition, climbBarPresentTime
            // Use accel to bring velocity up to maxVel, then maintain maxVel till we need to decel such that we hit targPos at minVel
            // maintain minVel till bar is detected continuously for barTime, then clamp.
            // We should handle the condition where we may need to being decel before reaching maxVel in order to meet the minVel target at TargetPosition.
            if (adjustVelocity()) // keep calling adjustVelocity() till it returns true.
                {
                climbState = ENSUREHIGHBAR;
                }
            // time need to reach minVelocity by the time we get to target position is fairly simple if we're at MaxVel.  Otherwise, it's more complicated.
            break;        
        case ENSUREHIGHBAR: // Note that we still have climbMinVelocity active so climber arm will still be moving (unless climbMinVelocity is set at 0)
            // Now, we're going the other way to get the claw off of the mid bar.  There's no hard stop so we can really move as long as we stop in a controlled manner that minimizes swing
            // Note that swing introduction could be a bit different for this motion since the robot could be crossing the center of gravity of the high bar at a fair clip.
            // Mind you this is the point where we should be approaching a fairly low velocity as well so swing can be minimized.
            climbAccel = -142.59;
            climbDecel = -142.59;
            climbMaxVelocity = -71.3;
            climbMinVelocity = -2.0;
            climbTargetPosition = -9.5;
            climbSubState = 0; 
            break;
        case SWING1: // swing and Lift Off Mid Bar.
            if (adjustVelocity()) // keep calling adjustVelocity() till it returns true.
                {
                climbState = LIFTOFFMIDBAR;
                }
            break;       
        case LIFTOFFMIDBAR: // lifting off the bar
            break;        
        case MOVETOTRAVERSEBAR:
            break;
        case GRABTRAVERSEBAR:
            break;
        case ENSUREGRABTRAVERSEBAR:
            break;
        case SWING2: // second swing
            break;
        case LIFTOFFHIGHBAR:
            break;

    }

    }

void Climber::ClimbDown() // Called at 50Hz to have climbing system climb in the upward direction
    { 

    }

int Climber::GetClimberSubState() {
    return climbSubState; // Should not retract to low unless climbSubState is VERTICALTOFROMMIDBAR or HORIZONTALTOFROMVERTICAL (0 or 1)
}



// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS

// Original Climb Code using position only.
//double positionIncrementForSlowMovement = 0.05; //When we want to move the arm against the bar we will keep increasing its target position by this much
//double climberMotorAllowedError = 3;
// auto delayForDetectingBar = 1_s; //how many counts we need to see the bar for before we move on in seconds
// auto delayForPneumaticMovement = 1_s; //time delay to allow the pneumatics to move in seconds
// auto delayForMotorMovement = 1_s;
// auto originalTime = 0_s;
// auto timeOut = 0_s;

//    switch (climbState){
//         case CLIMBINGSETUP:
//             RaiseClimber();
//             SetClimberPosition(straightUpPosition);

//             if (!(abs(climberEncoder.GetPosition() - straightUpPosition) < climberMotorAllowedError)){
//                 originalTime = frc::Timer::GetFPGATimestamp();
//             }
//             if ((frc::Timer::GetFPGATimestamp() - originalTime) >= delayForMotorMovement){
//                 climbState=DRIVINGTOBAR;
//                 timeOut = frc::Timer::GetFPGATimestamp();
//             }

//             ExtendReachingArm();
//             Unlock();

//             break;

//         case DRIVINGTOBAR:
//             // drivebase: drive backward
            
//             /*if (reachLimit1.Get() == true){ //if we do not see the bar keep resetting originalTime
//                 originalTime = frc::Timer::GetFPGATimestamp();
//             }*/
//             if ((frc::Timer::GetFPGATimestamp() - originalTime)>=delayForDetectingBar){
//                 climbState=GRABHIGHBAR;
//             }

//             ///
//             if (frc::Timer::GetFPGATimestamp() - timeOut > 5_s) {
//                 climbState=GRABHIGHBAR;
//                 timeOut = frc::Timer::GetFPGATimestamp();
//             }
//             break;

//         case GRABHIGHBAR:
//             SetClimberPosition(grabHighBarPosition);

//             if (!(abs(climberEncoder.GetPosition() - grabHighBarPosition) < climberMotorAllowedError)){
//                 originalTime = frc::Timer::GetFPGATimestamp();
//             }
//             if ((frc::Timer::GetFPGATimestamp() - originalTime) >= delayForMotorMovement){
//                 climbState=ENSUREHIGHBAR;
//                 timeOut = frc::Timer::GetFPGATimestamp();
//             }
//             break;
        
//         case ENSUREHIGHBAR:
//             grabHighBarPosition += positionIncrementForSlowMovement;
//             SetClimberPosition(grabHighBarPosition);

//            /* if (lockLimit.Get() == true){
//                 originalTime = frc::Timer::GetFPGATimestamp();
//             }*/

//             if ((frc::Timer::GetFPGATimestamp() - originalTime)>=delayForDetectingBar){      
//                 Lock();
//             }

//             if ((frc::Timer::GetFPGATimestamp() - originalTime)>=delayForDetectingBar+delayForPneumaticMovement){
//                 climbState=SWING1;
//                 timeOut = frc::Timer::GetFPGATimestamp();
//             }

//             // Temporary code
//             if (frc::Timer::GetFPGATimestamp() - timeOut > 3_s) {
//                 Lock();
//             }
            
//             //
//             if (frc::Timer::GetFPGATimestamp() - timeOut > 4_s) {
//                 climbState=SWING1;
//                 timeOut = frc::Timer::GetFPGATimestamp();
//             }
//             break;

//         case SWING1: // swing
//             SetClimberPosition(swing1Position); // need to find the position
//             if (!(abs(climberEncoder.GetPosition() - swing1Position) < climberMotorAllowedError)){
//                 originalTime = frc::Timer::GetFPGATimestamp();
//             }

//             if ((frc::Timer::GetFPGATimestamp() - originalTime) >= delayForMotorMovement){
//                 climbState=LIFTOFFMIDBAR;
//                 timeOut = frc::Timer::GetFPGATimestamp();
//             }
//             break;
        
//         case LIFTOFFMIDBAR: // lifting off the bar
//             SetClimberPosition(liftOffMediumBarPosition); // need to find the position
            
//             if (!(abs(climberEncoder.GetPosition() - liftOffMediumBarPosition) < climberMotorAllowedError)){
//                 originalTime = frc::Timer::GetFPGATimestamp();  
//             }

//             if ((frc::Timer::GetFPGATimestamp() - originalTime) >= delayForMotorMovement){
//                 RetractReachingArm(); 
//             }

//             if ((frc::Timer::GetFPGATimestamp() - originalTime) >= (delayForDetectingBar+delayForPneumaticMovement)){
//                 climbState=MOVETOTRAVERSEBAR;
//                 timeOut = frc::Timer::GetFPGATimestamp();
//             }
//             break;
        
//         case MOVETOTRAVERSEBAR:
//             SetClimberPosition(swingToTraverseBarPosition); // find the position

//             if (!(abs(climberEncoder.GetPosition() - swingToTraverseBarPosition) < climberMotorAllowedError)){
//                 originalTime = frc::Timer::GetFPGATimestamp();    
//             }

//             if ((frc::Timer::GetFPGATimestamp() - originalTime) >= delayForMotorMovement){
//                 ExtendReachingArm();
//             }

//             if ((frc::Timer::GetFPGATimestamp() - originalTime)>=delayForDetectingBar+delayForPneumaticMovement){
//                 climbState=GRABTRAVERSEBAR;
//                 timeOut = frc::Timer::GetFPGATimestamp();
//             }
//             break;

//         case GRABTRAVERSEBAR:
//             SetClimberPosition(grabTraverseBarPosition);

//             if (!(abs(climberEncoder.GetPosition() - grabTraverseBarPosition) < climberMotorAllowedError)){
//                 originalTime = frc::Timer::GetFPGATimestamp();      
//             }

//             if ((frc::Timer::GetFPGATimestamp() - originalTime) >= delayForMotorMovement){
//                 climbState=ENSUREGRABTRAVERSEBAR;
//                 timeOut = frc::Timer::GetFPGATimestamp();
//             }
//             break;

//         case ENSUREGRABTRAVERSEBAR:
//             grabTraverseBarPosition -= positionIncrementForSlowMovement;
//             SetClimberPosition(grabTraverseBarPosition);
//             /*if (reachLimit2.Get() == true){
//                 originalTime = frc::Timer::GetFPGATimestamp();  
//             }*/     
//             if ((frc::Timer::GetFPGATimestamp() - originalTime) >= delayForMotorMovement){
//                 climbState=SWING2;
//                 timeOut = frc::Timer::GetFPGATimestamp();
//                 Unlock();
//             }


//             // Temporary code
//             if (frc::Timer::GetFPGATimestamp() - timeOut > 2_s) {
//                 Unlock();
//             }
            
//             if (frc::Timer::GetFPGATimestamp() - timeOut > 3_s) {
//                 climbState=SWING2;
//                 timeOut = frc::Timer::GetFPGATimestamp();
//             }
//             break;

//         case SWING2: // second swing
//             SetClimberPosition(finalSwingPosition); // need to find the position
            
//             if (!(abs(climberEncoder.GetPosition() - finalSwingPosition) < climberMotorAllowedError)){   
//                 originalTime = frc::Timer::GetFPGATimestamp();    
//             }

//             if ((frc::Timer::GetFPGATimestamp() - originalTime) >= delayForMotorMovement){
//                 Unlock();
//             }

//             if ((frc::Timer::GetFPGATimestamp() - originalTime)>=delayForDetectingBar+delayForPneumaticMovement){
//                 climbState=LIFTOFFHIGHBAR;
//                 timeOut = frc::Timer::GetFPGATimestamp();
//             }

//             // Temporary code
//             if (frc::Timer::GetFPGATimestamp() - timeOut > 5_s) {
//                 climbState=LIFTOFFHIGHBAR;
//                 timeOut = frc::Timer::GetFPGATimestamp();
//             }
//             break;

//         case LIFTOFFHIGHBAR:
//             SetClimberPosition(liftOffHighBarPosition); // find the position
//             break;

//     }

// Put methods for controlling this subsystem
// here. Call these from Commands.

